# DNA Center API Interactive Menu Script with Device Filtering
# Author: In Memory of Zesty.PS1

# Allow script to run
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

# Handle errors gracefully
$ErrorActionPreference = "Continue"

# DNA Center URLs - UPDATE THESE WITH YOUR ENVIRONMENT DETAILS
$servers = @(
    [pscustomobject]@{ Name = "Tst DNA Center"; Url = "test" },
    [pscustomobject]@{ Name = "Tst DNA Center"; Url = "test2" }
)

function Select-DnaCenterServer {
    param (
        [Parameter(Mandatory)]
        [array]$Servers
    )

    if (-not $Servers -or $Servers.Count -eq 0) {
        throw "No DNA Center servers defined. Please populate `$servers with at least one entry."
    }

    if ($Servers.Count -eq 1) {
        Write-Host "Using DNA Center server: $($Servers[0].Name) ($($Servers[0].Url))" -ForegroundColor Cyan
        return $Servers[0].Url
    }

    Write-Host "Select the DNA Center server you want to use:" -ForegroundColor Cyan
    for ($i = 0; $i -lt $Servers.Count; $i++) {
        Write-Host ("  {0}. {1} ({2})" -f ($i + 1), $Servers[$i].Name, $Servers[$i].Url) -ForegroundColor Yellow
    }

    while ($true) {
        $selection = 0
        $input = Read-Host "Enter the number of the server you want to use"

        if ([int]::TryParse($input.Trim(), [ref]$selection)) {
            if ($selection -ge 1 -and $selection -le $Servers.Count) {
                $chosen = $Servers[$selection - 1]
                Write-Host "Selected DNA Center server: $($chosen.Name) ($($chosen.Url))" -ForegroundColor Green
                return $chosen.Url
            }
        }

        Write-Host "Invalid choice. Please enter a number between 1 and $($Servers.Count)." -ForegroundColor Red
    }
}

$dnaCenter = Select-DnaCenterServer -Servers $servers

# Output directory for CSV files
$outputDir = "C:\DNACenter_Reports"
if (-not (Test-Path $outputDir)) {
    New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
}

# Global variable to store selected devices
$global:selectedDevices = @()
$global:allDevices = @()

# ASCII Art Banner
function Show-Banner {
    Clear-Host
    $banner = @"
 ██████╗ ███╗   ██╗ ██████╗      ██████╗██████╗███╗   ██╗████████╗
 ██╔══██╗████╗  ██║██╔══██╗    ██╔════╝██╔════╝████╗  ██║╚══██╔══╝
 ██║  ██║██╔██╗ ██║███████║    ██║     █████╗  ██╔██╗ ██║   ██║
 ██║  ██║██║╚██╗██║██╔══██║    ██║     ██╔══╝  ██║╚██╗██║   ██║
 ██████╔╝██║ ╚████║██║  ██║    ╚██████╗███████╗██║ ╚████║   ██║
 ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝     ╚═════╝╚══════╝╚═╝  ╚═══╝   ╚═╝

  ██████╗ ██████╗██╗     ████████╗ ██████╗  ██████╗ ██╗
 ██╔══██╗██╔══██╗██║     ╚══██╔══╝██╔═══██╗██╔═══██╗██║
 ███████║██████╔╝██║        ██║   ██║   ██║██║   ██║██║
 ██╔══██║██╔═══╝ ██║        ██║   ██║   ██║██║   ██║██║
 ██║  ██║██║     ██║        ██║   ╚██████╔╝╚██████╔╝███████╗

	   Cisco DNA Center API Interface
	   Network Management Tool v1.0 
	   Courtesy of MECHAREA
"@
    
    Write-Host $banner -ForegroundColor Cyan
    Start-Sleep -Milliseconds 500
}

# Animated progress bar
function Show-ProgressBar {
    param(
        [int]$Current,
        [int]$Total,
        [string]$Activity
    )
    
    if ($Total -eq 0) { return }
    
    $percent = [math]::Round(($Current / $Total) * 100)
    $barLength = 50
    $filled = [math]::Floor($percent / 2)
    
    Write-Host "`r[" -NoNewline -ForegroundColor Cyan
    Write-Host ("█" * $filled) -NoNewline -ForegroundColor Cyan
    Write-Host ("░" * ($barLength - $filled)) -NoNewline -ForegroundColor DarkGray
    Write-Host "] $percent% - $Activity" -NoNewline -ForegroundColor Cyan
}

# Function to check task status (for async operations)
function Wait-ForTask {
    param(
        [string]$TaskId,
        [hashtable]$Headers,
        [string]$DnaCenter,
        [int]$TimeoutSeconds = 300
    )
    
    $startTime = Get-Date
    $completed = $false
    
    Write-Host "`nWaiting for task to complete..." -ForegroundColor Yellow
    
    while (-not $completed) {
        Start-Sleep -Seconds 2
        
        try {
            $taskResponse = Invoke-RestMethod -Uri "$DnaCenter/dna/intent/api/v1/task/$TaskId" -Method Get -Headers $Headers
            
            if ($taskResponse.response) {
                $task = $taskResponse.response
                
                if ($task.isError) {
                    Write-Host "`n✗ Task failed: $($task.failureReason)" -ForegroundColor Red
                    return $null
                }
                
                if ($task.endTime) {
                    $completed = $true
                    Write-Host "`n✓ Task completed successfully" -ForegroundColor Green
                    return $task
                }
                
                # Show progress
                if ($task.progress) {
                    Write-Host "`r  Progress: $($task.progress)" -NoNewline -ForegroundColor Cyan
                }
            }
        } catch {
            Write-Host "`n✗ Error checking task status: $($_.Exception.Message)" -ForegroundColor Red
            return $null
        }
        
        # Check timeout
        $elapsed = ((Get-Date) - $startTime).TotalSeconds
        if ($elapsed -gt $TimeoutSeconds) {
            Write-Host "`n✗ Task timed out after $TimeoutSeconds seconds" -ForegroundColor Red
            return $null
        }
    }
    
    return $taskResponse.response
}

# Function to authenticate and get token
function Get-DNACToken {
    param (
        [string]$dnaCenter
    )
    
    Write-Host ""
    Write-Host "╔════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "         Authentication Required                    " -ForegroundColor Cyan
    Write-Host "╚════════════════════════════════════════╝" -ForegroundColor Cyan
    Write-Host ""
    
    # Simple console input method
    Write-Host "Enter DNA Center Username: " -NoNewline -ForegroundColor Yellow
    $username = Read-Host
    
    Write-Host "Enter DNA Center Password: " -NoNewline -ForegroundColor Yellow
    $securePassword = Read-Host -AsSecureString
    
    $BSTR = [IntPtr]::Zero
    $password = $null
    $base64AuthInfo = $null

    try {
        # Convert secure string to plain text
        $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($securePassword)
        $password = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)

        # Create Base64 encoded credentials
        $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $username, $password)))

        # Bypass certificate validation
        if (-not ([System.Management.Automation.PSTypeName]'ServerCertificateValidationCallback').Type) {
            $certCallback = @"
            using System;
            using System.Net;
            using System.Net.Security;
            using System.Security.Cryptography.X509Certificates;
            public class ServerCertificateValidationCallback
            {
                public static void Ignore()
                {
                    if(ServicePointManager.ServerCertificateValidationCallback == null)
                    {
                        ServicePointManager.ServerCertificateValidationCallback +=
                            delegate
                            (
                                Object obj,
                                X509Certificate certificate,
                                X509Chain chain,
                                SslPolicyErrors errors
                            )
                            {
                                return true;
                            };
                    }
                }
            }
"@
            Add-Type $certCallback
        }
        [ServerCertificateValidationCallback]::Ignore()
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12

        # Get authentication token
        $authUrl = "$dnaCenter/dna/system/api/v1/auth/token"
        $headers = @{
            "Authorization" = "Basic $base64AuthInfo"
            "Content-Type" = "application/json"
        }

        try {
            Write-Host "`nAuthenticating..." -ForegroundColor Yellow
            $response = Invoke-RestMethod -Uri $authUrl -Method Post -Headers $headers

            if ($response -and $response.Token) {
                Write-Host ""
                Write-Host "✓ Authentication successful!" -ForegroundColor Green
                Write-Host "✓ Token acquired" -ForegroundColor Green
                Start-Sleep -Milliseconds 800
                return $response.Token
            } else {
                Write-Host "✗ No token received from server" -ForegroundColor Red
                return $null
            }
        } catch {
            Write-Host ""
            Write-Host "✗ Authentication failed" -ForegroundColor Red
            Write-Host "✗ Error: $($_.Exception.Message)" -ForegroundColor Red
            return $null
        }
    }
    finally {
        if ($BSTR -ne [IntPtr]::Zero) {
            [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($BSTR)
        }
        $password = $null
        $base64AuthInfo = $null
    }
}

# Function to load all devices
function Load-AllDevices {
    param($headers, $dnaCenter)

    Write-Host ""
    Write-Host "Loading network devices..." -ForegroundColor Yellow

    try {
        $pageSize = 500
        $offset = 1
        $pagesFetched = 0
        $aggregatedDevices = [System.Collections.Generic.List[object]]::new()

        while ($true) {
            $uri = "$dnaCenter/dna/intent/api/v1/network-device?offset=$offset&limit=$pageSize"
            $response = Invoke-RestMethod -Uri $uri -Method Get -Headers $headers

            $pageDevices = @()
            if ($response) {
                if ($response.PSObject -and $response.PSObject.Properties['response']) {
                    $pageDevices = $response.response
                }
                elseif ($response -is [System.Collections.IEnumerable] -and -not ($response -is [string])) {
                    $pageDevices = $response
                }
            }

            $retrievedCount = if ($pageDevices) { $pageDevices.Count } else { 0 }

            if ($retrievedCount -le 0) {
                if ($pagesFetched -eq 0) {
                    Write-Host "✗ No devices returned from API" -ForegroundColor Red
                }
                break
            }

            foreach ($device in $pageDevices) {
                $aggregatedDevices.Add($device)
            }

            $pagesFetched++
            Write-Host "  → Retrieved $retrievedCount device(s) from page $pagesFetched" -ForegroundColor Cyan

            if ($retrievedCount -lt $pageSize) {
                break
            }

            $offset += $pageSize
        }

        if ($aggregatedDevices.Count -gt 0) {
            $global:allDevices = $aggregatedDevices.ToArray()
            $global:selectedDevices = @()
            $pageSummary = if ($pagesFetched -gt 1) { " across $pagesFetched page(s)" } else { "" }
            Write-Host "✓ Loaded $($global:allDevices.Count) devices$pageSummary" -ForegroundColor Green
            Start-Sleep -Milliseconds 500
            return $true
        }

        return $false
    } catch {
        Write-Host "✗ Failed to load devices: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to display device selection menu
function Show-DeviceSelectionMenu {
    Clear-Host
    Write-Host ""
    Write-Host "    ╔═════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "    ║            Device Filter Options                                ║" -ForegroundColor Cyan
    Write-Host "    ╚═════════════════════════════════════════════════╝" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "    1. All Devices" -ForegroundColor White
    Write-Host "    2. Select by Hostname" -ForegroundColor White
    Write-Host "    3. Select by IP Address" -ForegroundColor White
    Write-Host "    4. Filter by Device Role" -ForegroundColor White
    Write-Host "    5. Filter by Device Family" -ForegroundColor White
    Write-Host ""
    Write-Host "    0. Back to Main Menu" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "    ══════════════════════════════════════════════════" -ForegroundColor Cyan
}

# Function to select devices
function Select-Devices {
    param($headers, $dnaCenter)
    
    do {
        Show-DeviceSelectionMenu
        $choice = Read-Host "`nSelect option"
        
        switch ($choice) {
            "1" {
                $global:selectedDevices = $global:allDevices
                Write-Host "`n✓ Selected all $($global:selectedDevices.Count) devices`n" -ForegroundColor Green
                Start-Sleep -Seconds 1
                return
            }
            "2" {
                Clear-Host
                Write-Host "`nAvailable Devices:`n" -ForegroundColor Cyan
                for ($i = 0; $i -lt $global:allDevices.Count; $i++) {
                    $hostname = if ($global:allDevices[$i].hostname) { $global:allDevices[$i].hostname } else { "Unknown" }
                    $ip = if ($global:allDevices[$i].managementIpAddress) { $global:allDevices[$i].managementIpAddress } else { "N/A" }
                    Write-Host "  $($i+1). $hostname - $ip" -ForegroundColor White
                }
                
                Write-Host "`nEnter device numbers (comma-separated) or 'all':" -ForegroundColor Yellow
                $input = Read-Host
                
                if ($input.ToLower() -eq "all") {
                    $global:selectedDevices = $global:allDevices
                } else {
                    $indices = $input -split ',' | ForEach-Object { 
                        try { [int]$_.Trim() - 1 } catch { -1 }
                    }
                    $global:selectedDevices = @()
                    foreach ($index in $indices) {
                        if ($index -ge 0 -and $index -lt $global:allDevices.Count) {
                            $global:selectedDevices += $global:allDevices[$index]
                        }
                    }
                }
                
                Write-Host "`n✓ Selected $($global:selectedDevices.Count) device(s)" -ForegroundColor Green
                $global:selectedDevices | ForEach-Object { 
                    $hostname = if ($_.hostname) { $_.hostname } else { "Unknown" }
                    Write-Host "  → $hostname" -ForegroundColor Cyan 
                }
                Start-Sleep -Seconds 2
                return
            }
            "3" {
                Write-Host "`nEnter IP address(es) (comma-separated):" -ForegroundColor Yellow
                $ips = Read-Host
                $ipList = $ips -split ',' | ForEach-Object { $_.Trim() }
                
                $global:selectedDevices = $global:allDevices | Where-Object { 
                    $_.managementIpAddress -and ($ipList -contains $_.managementIpAddress)
                }
                
                Write-Host "`n✓ Selected $($global:selectedDevices.Count) device(s)" -ForegroundColor Green
                $global:selectedDevices | ForEach-Object { 
                    $hostname = if ($_.hostname) { $_.hostname } else { "Unknown" }
                    $ip = if ($_.managementIpAddress) { $_.managementIpAddress } else { "N/A" }
                    Write-Host "  → $hostname ($ip)" -ForegroundColor Cyan 
                }
                Start-Sleep -Seconds 2
                return
            }
            "4" {
                Clear-Host
                $roles = $global:allDevices | Where-Object { $_.role } | Select-Object -ExpandProperty role -Unique | Sort-Object
                
                if ($roles.Count -eq 0) {
                    Write-Host "`n✗ No roles found in device data" -ForegroundColor Red
                    Start-Sleep -Seconds 2
                    continue
                }
                
                Write-Host "`nAvailable Roles:`n" -ForegroundColor Cyan
                for ($i = 0; $i -lt $roles.Count; $i++) {
                    $count = ($global:allDevices | Where-Object { $_.role -eq $roles[$i] }).Count
                    Write-Host "  $($i+1). $($roles[$i]) ($count devices)" -ForegroundColor White
                }
                
                Write-Host "`nEnter role number(s) (comma-separated):" -ForegroundColor Yellow
                $input = Read-Host
                $indices = $input -split ',' | ForEach-Object { 
                    try { [int]$_.Trim() - 1 } catch { -1 }
                }
                
                $selectedRoles = @()
                foreach ($index in $indices) {
                    if ($index -ge 0 -and $index -lt $roles.Count) {
                        $selectedRoles += $roles[$index]
                    }
                }
                
                $global:selectedDevices = $global:allDevices | Where-Object { $selectedRoles -contains $_.role }
                
                Write-Host "`n✓ Selected $($global:selectedDevices.Count) devices with role: $($selectedRoles -join ', ')" -ForegroundColor Green
                Start-Sleep -Seconds 2
                return
            }
            "5" {
                Clear-Host
                $families = $global:allDevices | Where-Object { $_.family } | Select-Object -ExpandProperty family -Unique | Sort-Object
                
                if ($families.Count -eq 0) {
                    Write-Host "`n✗ No families found in device data" -ForegroundColor Red
                    Start-Sleep -Seconds 2
                    continue
                }
                
                Write-Host "`nAvailable Device Families:`n" -ForegroundColor Cyan
                for ($i = 0; $i -lt $families.Count; $i++) {
                    $count = ($global:allDevices | Where-Object { $_.family -eq $families[$i] }).Count
                    Write-Host "  $($i+1). $($families[$i]) ($count devices)" -ForegroundColor White
                }
                
                Write-Host "`nEnter family number(s) (comma-separated):" -ForegroundColor Yellow
                $input = Read-Host
                $indices = $input -split ',' | ForEach-Object { 
                    try { [int]$_.Trim() - 1 } catch { -1 }
                }
                
                $selectedFamilies = @()
                foreach ($index in $indices) {
                    if ($index -ge 0 -and $index -lt $families.Count) {
                        $selectedFamilies += $families[$index]
                    }
                }
                
                $global:selectedDevices = $global:allDevices | Where-Object { $selectedFamilies -contains $_.family }
                
                Write-Host "`n✓ Selected $($global:selectedDevices.Count) devices" -ForegroundColor Green
                Start-Sleep -Seconds 2
                return
            }
            "0" {
                return
            }
            default {
                Write-Host "`n✗ Invalid selection" -ForegroundColor Red
                Start-Sleep -Seconds 1
            }
        }
    } while ($true)
}

# Function to display menu
function Show-Menu {
    Clear-Host
    Write-Host ""
    Write-Host "    ╔═══════════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "    ║              DNA Center API Main Menu                 ║" -ForegroundColor Cyan
    Write-Host "    ╚═══════════════════════════════════════════════════════╝" -ForegroundColor Cyan
    Write-Host ""
    
    if ($global:selectedDevices.Count -gt 0) {
        Write-Host "    Current Filter: $($global:selectedDevices.Count) device(s) selected" -ForegroundColor Yellow
    } else {
        Write-Host "    Current Filter: All devices" -ForegroundColor Green
    }
    Write-Host ""
    Write-Host "    ┌─────────────────────────────────────────────────────┐" -ForegroundColor Cyan
    Write-Host "    │  Device Selection                                   │" -ForegroundColor Cyan
    Write-Host "    └─────────────────────────────────────────────────────┘" -ForegroundColor Cyan
    Write-Host "    99. Configure Device Filter" -ForegroundColor Magenta
    Write-Host ""
    Write-Host "    ┌─────────────────────────────────────────────────────┐" -ForegroundColor Cyan
    Write-Host "    │  Advanced Operations                                │" -ForegroundColor Cyan
    Write-Host "    └─────────────────────────────────────────────────────┘" -ForegroundColor Cyan
    Write-Host "    21. Command Runner (Execute CLI Commands)" -ForegroundColor Yellow
    Write-Host "    22. Path Trace (Network Path Analysis)" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "    ┌─────────────────────────────────────────────────────┐" -ForegroundColor Cyan
    Write-Host "    │  Standard Reports                                  │" -ForegroundColor Cyan
    Write-Host "    └─────────────────────────────────────────────────────┘" -ForegroundColor Cyan
    Write-Host "     1. Network Devices (Basic Info)" -ForegroundColor White
    Write-Host "     2. Network Devices (Detailed)" -ForegroundColor White
    Write-Host "     3. Device Configurations" -ForegroundColor White
    Write-Host "     4. Device Interfaces" -ForegroundColor White
    Write-Host "     5. Device Inventory Count" -ForegroundColor White
    Write-Host "     6. Sites/Locations" -ForegroundColor White
    Write-Host "     7. Network Health" -ForegroundColor White
    Write-Host "     8. Client Health" -ForegroundColor White
    Write-Host "     9. Compliance Status" -ForegroundColor White
    Write-Host "    10. Device Reachability Status" -ForegroundColor White
    Write-Host "    11. VLANs" -ForegroundColor White
    Write-Host "    12. Software/Image Information" -ForegroundColor White
    Write-Host "    13. Issues/Events" -ForegroundColor White
    Write-Host "    14. Templates" -ForegroundColor White
    Write-Host "    15. Physical Topology" -ForegroundColor White
    Write-Host "    16. Device Module Information" -ForegroundColor White
    Write-Host "    17. OSPF Neighbors" -ForegroundColor White
    Write-Host "    18. CDP Neighbors" -ForegroundColor White
    Write-Host "    19. LLDP Neighbors" -ForegroundColor White
    Write-Host "    20. Access Points" -ForegroundColor White
    Write-Host ""
    Write-Host "     0. Exit" -ForegroundColor Red
    Write-Host ""
    Write-Host "    ════════════════════════════════════════════════════════" -ForegroundColor Cyan
    Write-Host ""
}

# Function to get filtered devices for processing
function Get-FilteredDevices {
    if ($global:selectedDevices.Count -gt 0) {
        return $global:selectedDevices
    } else {
        return $global:allDevices
    }
}

# Helper to surface an empty selection before running device-centric reports
function Get-ActiveDevices {
    $devices = Get-FilteredDevices

    if (-not $devices -or $devices.Count -eq 0) {
        Write-Host "✗ No devices available. Load inventory or choose devices with option 99 first." -ForegroundColor Red
        return $null
    }

    return $devices
}

# Helper to centralise CSV export messaging and prevent misleading success output
function Export-Report {
    param(
        [Parameter(Mandatory)]
        [System.Collections.IEnumerable]$Rows,

        [Parameter(Mandatory)]
        [string]$BaseName,

        [Parameter(Mandatory)]
        [string]$RecordLabel,

        [string]$Timestamp
    )

    $rowBuffer = @()
    foreach ($row in @($Rows)) {
        if ($null -ne $row) {
            $rowBuffer += $row
        }
    }

    if ($rowBuffer.Count -eq 0) {
        Write-Host ("! No {0} found. Skipping export." -f $RecordLabel) -ForegroundColor Yellow
        return $null
    }

    if (-not $Timestamp) {
        $Timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    }

    $fileName = "{0}_{1}.csv" -f $BaseName, $Timestamp
    $csvPath = Join-Path -Path $outputDir -ChildPath $fileName

    $rowBuffer | Export-Csv -Path $csvPath -NoTypeInformation

    Write-Host ("✓ Exported to: {0}" -f $csvPath) -ForegroundColor Green
    Write-Host ("✓ Total {0}: {1}" -f $RecordLabel, $rowBuffer.Count) -ForegroundColor Green

    return $csvPath
}

function Convert-GroupToRows {
    param(
        [System.Collections.IEnumerable]$Groups,
        [string]$PropertyName,
        [switch]$SortDescending
    )

    $rows = @()

    foreach ($group in @($Groups)) {
        if ($null -eq $group) { continue }

        $value = $group.Name
        if ([string]::IsNullOrWhiteSpace([string]$value)) {
            $value = "Unknown"
        }

        $row = [ordered]@{}
        $row[$PropertyName] = $value
        $row["Count"] = $group.Count

        $rows += [PSCustomObject]$row
    }

    if ($SortDescending) {
        return $rows |
            Sort-Object -Property @{
                Expression = { $_.Count }
                Descending = $true
            }, @{
                Expression = { $_.$PropertyName }
                Descending = $false
            }
    }

    return $rows
}

function Get-SafeFileName {
    param(
        [string]$InputName,
        [string]$Fallback = "output"
    )

    if ([string]::IsNullOrWhiteSpace($InputName)) {
        $InputName = $Fallback
    }

    return ($InputName -replace '[\\/:*?"<>|]', '_')
}

function Get-FirstPropertyValue {
    param(
        [object]$Object,
        [string[]]$PropertyNames
    )

    if ($null -eq $Object -or -not $PropertyNames -or $PropertyNames.Count -eq 0) {
        return $null
    }

    foreach ($propertyName in $PropertyNames) {
        if ([string]::IsNullOrWhiteSpace($propertyName)) { continue }

        $property = $Object.PSObject.Properties[$propertyName]
        if ($null -eq $property) { continue }

        $value = $property.Value
        if ($null -eq $value) { continue }

        if ($value -is [string]) {
            if (-not [string]::IsNullOrWhiteSpace($value)) {
                return $value
            }
        }
        else {
            return $value
        }
    }

    return $null
}

function ConvertTo-ReadableTimestamp {
    param(
        [object]$Value
    )

    if ($null -eq $Value) {
        return $null
    }

    if ($Value -is [DateTime]) {
        return ($Value.ToUniversalTime().ToString("u"))
    }

    if ($Value -is [DateTimeOffset]) {
        return ($Value.ToUniversalTime().ToString("u"))
    }

    if ($Value -is [string]) {
        if ([string]::IsNullOrWhiteSpace($Value)) {
            return $null
        }

        if ($Value -match '^-?\d+$') {
            try {
                return ConvertTo-ReadableTimestamp([long]$Value)
            }
            catch {
                return $Value
            }
        }

        try {
            $parsed = Get-Date $Value
            return ($parsed.ToUniversalTime().ToString("u"))
        }
        catch {
            return $Value
        }
    }

    if ($Value -is [long] -or $Value -is [int]) {
        $numeric = [long]$Value

        try {
            if ($numeric -gt 9999999999) {
                return ([DateTimeOffset]::FromUnixTimeMilliseconds($numeric)).UtcDateTime.ToString("u")
            }
            elseif ($numeric -gt 0) {
                return ([DateTimeOffset]::FromUnixTimeSeconds($numeric)).UtcDateTime.ToString("u")
            }
        }
        catch {
            return $numeric.ToString()
        }

        return $numeric.ToString()
    }

    if ($Value -is [double] -or $Value -is [decimal]) {
        try {
            $rounded = [long][Math]::Round([double]$Value)
            return ConvertTo-ReadableTimestamp($rounded)
        }
        catch {
            return $Value.ToString()
        }
    }

    return $Value.ToString()
}

function Get-EventSeriesLastTimestamp {
    param(
        [hashtable]$Headers,
        [string]$DnaCenter,
        [string]$DeviceId,
        [string]$EventId,
        [string]$EventName,
        [hashtable]$AdditionalQuery
    )

    if ([string]::IsNullOrWhiteSpace($DeviceId)) {
        return $null
    }

    $baseUrl = "$DnaCenter/dna/data/api/v1/event/event-series"

    $queryParts = @()

    if ($EventId) {
        $queryParts += "eventId=$([System.Uri]::EscapeDataString($EventId))"
    }

    if ($EventName) {
        $queryParts += "eventName=$([System.Uri]::EscapeDataString($EventName))"
    }

    $queryParts += "deviceId=$([System.Uri]::EscapeDataString($DeviceId))"
    $queryParts += "limit=1"
    $queryParts += "offset=0"
    $queryParts += "sortBy=eventTimestamp"
    $queryParts += "order=desc"

    if ($AdditionalQuery) {
        foreach ($entry in $AdditionalQuery.GetEnumerator()) {
            $key = $entry.Key
            $value = $entry.Value

            if ([string]::IsNullOrWhiteSpace([string]$key)) { continue }
            if ($null -eq $value -or [string]::IsNullOrWhiteSpace([string]$value)) { continue }

            $queryParts += "{0}={1}" -f [System.Uri]::EscapeDataString([string]$key), [System.Uri]::EscapeDataString([string]$value)
        }
    }

    $queryString = $queryParts -join '&'
    $requestUrl = if ($queryString) { "$baseUrl?$queryString" } else { $baseUrl }

    try {
        $response = Invoke-RestMethod -Uri $requestUrl -Method Get -Headers $Headers
    }
    catch {
        return $null
    }

    $records = @()
    if ($response) {
        if ($response.PSObject.Properties['response']) {
            $records = @($response.response)
        }
        elseif ($response.PSObject.Properties['data']) {
            $records = @($response.data)
        }
        elseif ($response.PSObject.Properties['eventSeries']) {
            $records = @($response.eventSeries)
        }
        elseif ($response.PSObject.Properties['eventSeriesDTOList']) {
            $records = @($response.eventSeriesDTOList)
        }
        elseif ($response.PSObject.Properties['items']) {
            $records = @($response.items)
        }
        elseif ($response -is [array]) {
            $records = @($response)
        }
        else {
            $records = @($response)
        }
    }

    foreach ($record in $records) {
        if (-not $record) { continue }

        $timestampValue = $null

        if ($record.PSObject.Properties['eventTimestamp']) {
            $timestampValue = $record.eventTimestamp
        }
        elseif ($record.PSObject.Properties['timestamp']) {
            $timestampValue = $record.timestamp
        }
        elseif ($record.PSObject.Properties['eventTime']) {
            $timestampValue = $record.eventTime
        }
        elseif ($record.PSObject.Properties['details']) {
            $details = $record.details
            if ($details) {
                if ($details.PSObject.Properties['eventTimestamp']) {
                    $timestampValue = $details.eventTimestamp
                }
                elseif ($details.PSObject.Properties['timestamp']) {
                    $timestampValue = $details.timestamp
                }
                elseif ($details.PSObject.Properties['eventTime']) {
                    $timestampValue = $details.eventTime
                }
            }
        }

        if (-not $timestampValue) {
            $nestedCollections = @()

            if ($record.PSObject.Properties['eventSeries']) {
                $nestedCollections += @($record.eventSeries)
            }

            if ($record.PSObject.Properties['events']) {
                $nestedCollections += @($record.events)
            }

            if ($record.PSObject.Properties['series']) {
                $nestedCollections += @($record.series)
            }

            if ($record.PSObject.Properties['records']) {
                $nestedCollections += @($record.records)
            }

            foreach ($collection in $nestedCollections) {
                foreach ($entry in @($collection)) {
                    if (-not $entry) { continue }

                    if ($entry.PSObject.Properties['eventTimestamp']) {
                        $timestampValue = $entry.eventTimestamp
                        break
                    }
                    elseif ($entry.PSObject.Properties['timestamp']) {
                        $timestampValue = $entry.timestamp
                        break
                    }
                    elseif ($entry.PSObject.Properties['eventTime']) {
                        $timestampValue = $entry.eventTime
                        break
                    }
                }

                if ($timestampValue) { break }
            }
        }

        if ($timestampValue) {
            return ConvertTo-ReadableTimestamp -Value $timestampValue
        }
    }

    return $null
}

function Get-LastDeviceAvailabilityEventTime {
    param(
        [hashtable]$Headers,
        [string]$DnaCenter,
        [string]$DeviceId,
        [string]$EventName
    )

    if ([string]::IsNullOrWhiteSpace($EventName)) {
        return $null
    }

    # Attempt lookup using the provided event name. Additional event identifiers can be
    # supplied here if they become available in the future.
    $queryHints = @{ tags = 'ASSURANCE' }

    $timestamp = Get-EventSeriesLastTimestamp -Headers $Headers -DnaCenter $DnaCenter -DeviceId $DeviceId -EventId $null -EventName $EventName -AdditionalQuery $queryHints

    if (-not $timestamp) {
        $timestamp = Get-EventSeriesLastTimestamp -Headers $Headers -DnaCenter $DnaCenter -DeviceId $DeviceId -EventId $null -EventName $EventName -AdditionalQuery $null
    }

    return $timestamp
}

function Get-LastDisconnectTime {
    param(
        [hashtable]$Headers,
        [string]$DnaCenter,
        [string]$DeviceId
    )

    if ([string]::IsNullOrWhiteSpace($DeviceId)) {
        return $null
    }

    $enrichmentUrl = "$DnaCenter/dna/intent/api/v1/network-device/$DeviceId/enrichment-details"

    try {
        $response = Invoke-RestMethod -Uri $enrichmentUrl -Method Get -Headers $Headers

        if (-not $response) {
            return $null
        }

        $records = @()
        if ($response.PSObject.Properties['response']) {
            $records = @($response.response)
        } elseif ($response -is [array]) {
            $records = @($response)
        } else {
            $records = @($response)
        }

        foreach ($record in $records) {
            if (-not $record) { continue }

            $deviceDetails = $null
            if ($record.PSObject.Properties['deviceDetails']) {
                $deviceDetails = $record.deviceDetails
            } elseif ($record.PSObject.Properties['deviceDetail']) {
                $deviceDetails = $record.deviceDetail
            } elseif ($record.PSObject.Properties['details']) {
                $deviceDetails = $record.details
            }

            if (-not $deviceDetails) { continue }

            $lastDisconnect = $null
            if ($deviceDetails.PSObject.Properties['lastDisconnectTime']) {
                $lastDisconnect = $deviceDetails.lastDisconnectTime
            }

            if (-not $lastDisconnect -and $deviceDetails.PSObject.Properties['detailAttributes']) {
                $attributes = $deviceDetails.detailAttributes
                if ($attributes -and $attributes.PSObject.Properties['lastDisconnectTime']) {
                    $lastDisconnect = $attributes.lastDisconnectTime
                }
            }

            if ($lastDisconnect) {
                return ConvertTo-ReadableTimestamp -Value $lastDisconnect
            }
        }

        return $null
    }
    catch {
        return $null
    }
}

function Get-LastPingReachableTime {
    param(
        [hashtable]$Headers,
        [string]$DnaCenter,
        [psobject]$Device
    )

    if (-not $Device) {
        return "N/A"
    }

    $lookupCandidates = @()

    if ($Device.PSObject.Properties['managementIpAddress']) {
        $managementIp = [string]$Device.managementIpAddress
        if (-not [string]::IsNullOrWhiteSpace($managementIp)) {
            $lookupCandidates += @{ Name = 'managementIpAddress'; Value = $managementIp }
        }
    }

    if ($Device.PSObject.Properties['hostname']) {
        $hostname = [string]$Device.hostname
        if (-not [string]::IsNullOrWhiteSpace($hostname)) {
            $lookupCandidates += @{ Name = 'hostname'; Value = $hostname }
        }
    }

    foreach ($candidate in $lookupCandidates) {
        try {
            $encodedValue = [uri]::EscapeDataString([string]$candidate.Value)
            $uri = "{0}/dna/intent/api/v1/network-device?{1}={2}" -f $DnaCenter, $candidate.Name, $encodedValue
            $response = Invoke-RestMethod -Uri $uri -Method Get -Headers $Headers -ErrorAction Stop

            $records = @()
            if ($response -and $response.PSObject.Properties['response']) {
                $payload = $response.response
                if ($payload -is [System.Collections.IEnumerable] -and -not ($payload -is [string])) {
                    $records = @($payload)
                }
                else {
                    $records = @($payload)
                }
            }
            elseif ($response) {
                if ($response -is [System.Collections.IEnumerable] -and -not ($response -is [string])) {
                    $records = @($response)
                }
                else {
                    $records = @($response)
                }
            }

            foreach ($record in @($records)) {
                if ($null -eq $record) { continue }

                $lastSeenValue = Get-FirstPropertyValue -Object $record -PropertyNames @(
                    'lastSeen',
                    'lastSeenTime',
                    'lastReachableTime',
                    'lastSuccessfulConnectionTime',
                    'lastUpdated'
                )

                if ($null -ne $lastSeenValue) {
                    $converted = ConvertTo-ReadableTimestamp $lastSeenValue
                    if ($converted) {
                        return $converted
                    }

                    return $lastSeenValue
                }
            }
        }
        catch {
            continue
        }
    }

    $deviceId = $null
    if ($Device.PSObject.Properties['id']) {
        $deviceId = [string]$Device.id
    }

    if (-not [string]::IsNullOrWhiteSpace($deviceId)) {
        $timestamp = Get-EventSeriesLastTimestamp -Headers $Headers -DnaCenter $DnaCenter -DeviceId $deviceId -EventName "device_availability:ping_reachable"

        if ($timestamp) {
            return $timestamp
        }

        $timestamp = Get-EventSeriesLastTimestamp -Headers $Headers -DnaCenter $DnaCenter -DeviceId $deviceId -EventName "device_availability:reachable"

        if ($timestamp) {
            return $timestamp
        }
    }

    return "N/A"
}

function Get-TaskFileId {
    param(
        [psobject]$TaskInfo
    )

    if (-not $TaskInfo) {
        return $null
    }

    if ($TaskInfo.fileId) {
        return $TaskInfo.fileId
    }

    if ($TaskInfo.additionalStatusURL -and $TaskInfo.additionalStatusURL -match '/file/([a-f0-9\-]+)') {
        return $Matches[1]
    }

    if ($TaskInfo.progress) {
        try {
            $progressObj = $TaskInfo.progress | ConvertFrom-Json
            if ($progressObj.fileId) {
                return $progressObj.fileId
            }
        }
        catch {
            if ($TaskInfo.progress -match '"fileId"\s*:\s*"([^"]+)"') {
                return $Matches[1]
            }
        }
    }

    return $null
}

function Invoke-DeviceCliCommand {
    param(
        [hashtable]$Headers,
        [string]$DnaCenter,
        [psobject]$Device,
        [string]$Command,
        [int]$TimeoutSeconds = 180
    )

    if (-not $Device -or -not $Device.id) {
        return $null
    }

    $requestBody = @{
        name        = "Cmd-$($Device.hostname)-$(Get-Random)"
        commands    = @($Command)
        deviceUuids = @($Device.id)
    } | ConvertTo-Json -Depth 10

    try {
        $submitResponse = Invoke-RestMethod -Uri "$DnaCenter/dna/intent/api/v1/network-device-poller/cli/read-request" `
            -Method Post `
            -Headers $Headers `
            -Body $requestBody `
            -ContentType "application/json"
    }
    catch {
        Write-Host "✗ Failed to submit '$Command' for $($Device.hostname): $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }

    if (-not $submitResponse -or -not $submitResponse.response -or -not $submitResponse.response.taskId) {
        Write-Host "✗ DNA Center did not return a task ID for '$Command' on $($Device.hostname)" -ForegroundColor Red
        return $null
    }

    $taskInfo = Wait-ForTask -TaskId $submitResponse.response.taskId -Headers $Headers -DnaCenter $DnaCenter -TimeoutSeconds $TimeoutSeconds
    if (-not $taskInfo) {
        return $null
    }

    $fileId = Get-TaskFileId -TaskInfo $taskInfo
    if (-not $fileId) {
        Write-Host "✗ Unable to determine output file ID for '$Command' on $($Device.hostname)" -ForegroundColor Red
        return $null
    }

    try {
        $fileResponse = Invoke-RestMethod -Uri "$DnaCenter/dna/intent/api/v1/file/$fileId" -Method Get -Headers $Headers
    }
    catch {
        Write-Host "✗ Failed to download CLI output for '$Command' on $($Device.hostname): $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }

    $taskRecord = [pscustomobject]@{
        Status = "Downloaded"
        Output = $fileResponse
        Filters = @()
    }

    $details = Get-TaskOutputDetails -Task $taskRecord
    return [pscustomobject]@{
        RawOutput = $details.CleanOutput
        Lines     = $details.OutputLines
    }
}

function Invoke-DeviceCliCommandBatch {
    param(
        [hashtable]$Headers,
        [string]$DnaCenter,
        [psobject[]]$Devices,
        [string]$Command,
        [int]$TimeoutSeconds = 300,
        [string]$ActivityLabel = "CLI command"
    )

    $results = @()

    if (-not $Devices -or $Devices.Count -eq 0) {
        return $results
    }

    Write-Host ""
    Write-Host "Submitting '$Command' to $($Devices.Count) device(s)..." -ForegroundColor Cyan

    $taskRecords = @()
    $submitCounter = 0
    $totalSubmissions = $Devices.Count

    foreach ($device in $Devices) {
        if (-not $device -or -not $device.id) { continue }

        $submitCounter++
        $hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
        Show-ProgressBar -Current $submitCounter -Total $totalSubmissions -Activity $hostname

        $requestBody = @{
            name        = "Cmd-$hostname-$(Get-Random)"
            commands    = @($Command)
            deviceUuids = @($device.id)
        } | ConvertTo-Json -Depth 10

        try {
            $response = Invoke-RestMethod -Uri "$DnaCenter/dna/intent/api/v1/network-device-poller/cli/read-request" `
                -Method Post `
                -Headers $Headers `
                -Body $requestBody `
                -ContentType "application/json"

            if ($response -and $response.response -and $response.response.taskId) {
                $taskRecords += [pscustomobject]@{
                    TaskId     = $response.response.taskId
                    Hostname   = $hostname
                    Device     = $device
                    DeviceId   = $device.id
                    DeviceIP   = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                    Command    = $Command
                    Status     = "Submitted"
                    FileId     = $null
                    Output     = $null
                    Filters    = @()
                    Error      = $null
                    SubmitTime = Get-Date
                }
            }
            else {
                $taskRecords += [pscustomobject]@{
                    TaskId     = $null
                    Hostname   = $hostname
                    Device     = $device
                    DeviceId   = $device.id
                    DeviceIP   = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                    Command    = $Command
                    Status     = "Submit Failed"
                    FileId     = $null
                    Output     = $null
                    Filters    = @()
                    Error      = "DNA Center did not return a task ID"
                    SubmitTime = Get-Date
                }
            }
        }
        catch {
            $errorMsg = $_.Exception.Message
            if ($_.ErrorDetails -and $_.ErrorDetails.Message) {
                $errorMsg = $_.ErrorDetails.Message
            }

            $taskRecords += [pscustomobject]@{
                TaskId     = $null
                Hostname   = $hostname
                Device     = $device
                DeviceId   = $device.id
                DeviceIP   = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                Command    = $Command
                Status     = "Error"
                FileId     = $null
                Output     = $null
                Filters    = @()
                Error      = $errorMsg
                SubmitTime = Get-Date
            }
        }

        Start-Sleep -Milliseconds 100
    }

    Write-Host ""
    Write-Host "✓ Submitted $submitCounter task(s)" -ForegroundColor Green

    $pendingTasks = $taskRecords | Where-Object { $_.TaskId -and $_.Status -eq "Submitted" }

    if ($pendingTasks.Count -gt 0) {
        Write-Host ""
        Write-Host "Waiting for '$Command' tasks to finish..." -ForegroundColor Cyan

        $startTime = Get-Date
        $checkInterval = 3

        while ($pendingTasks.Count -gt 0) {
            $elapsed = ((Get-Date) - $startTime).TotalSeconds

            if ($elapsed -gt $TimeoutSeconds) {
                foreach ($task in $pendingTasks) {
                    $task.Status = "Timed Out"
                    $task.Error = "Task timed out after $TimeoutSeconds seconds"
                }
                break
            }

            foreach ($task in $pendingTasks) {
                try {
                    $taskResponse = Invoke-RestMethod -Uri "$DnaCenter/dna/intent/api/v1/task/$($task.TaskId)" `
                        -Method Get `
                        -Headers $Headers

                    if ($taskResponse -and $taskResponse.response) {
                        $taskInfo = $taskResponse.response

                        if ($taskInfo.isError) {
                            $task.Status = "Failed"
                            $task.Error = if ($taskInfo.failureReason) { $taskInfo.failureReason } else { "Task reported an error" }
                        }
                        elseif ($taskInfo.endTime) {
                            $task.Status = "Completed"
                            $task.FileId = Get-TaskFileId -TaskInfo $taskInfo
                        }
                    }
                }
                catch {
                    # Continue polling remaining tasks
                }
            }

            $pendingTasks = $taskRecords | Where-Object { $_.Status -eq "Submitted" }

            $completedCount = ($taskRecords | Where-Object { $_.Status -in @("Completed", "Failed", "Error", "Timed Out") }).Count
            Show-ProgressBar -Current $completedCount -Total $taskRecords.Count -Activity $ActivityLabel

            if ($pendingTasks.Count -gt 0) {
                Start-Sleep -Seconds $checkInterval
            }
        }

        Write-Host ""
    }

    $downloadable = $taskRecords | Where-Object { $_.Status -eq "Completed" -and $_.FileId }

    if ($downloadable.Count -gt 0) {
        Write-Host "Downloading '$Command' results..." -ForegroundColor Cyan
        $downloadCounter = 0

        foreach ($task in $downloadable) {
            $downloadCounter++
            Show-ProgressBar -Current $downloadCounter -Total $downloadable.Count -Activity $task.Hostname

            try {
                $fileResponse = Invoke-RestMethod -Uri "$DnaCenter/dna/intent/api/v1/file/$($task.FileId)" -Method Get -Headers $Headers
                $task.Status = "Downloaded"
                $task.Output = $fileResponse
            }
            catch {
                $task.Status = "Download Failed"
                $task.Error = "Failed to download CLI output: $($_.Exception.Message)"
            }
        }

        Write-Host ""
    }

    foreach ($task in $taskRecords) {
        $details = Get-TaskOutputDetails -Task $task
        $task | Add-Member -NotePropertyName "CleanOutput" -NotePropertyValue $details.CleanOutput -Force
        $task | Add-Member -NotePropertyName "OutputLines" -NotePropertyValue $details.OutputLines -Force
    }

    foreach ($task in $taskRecords) {
        $results += [pscustomobject]@{
            Device    = $task.Device
            DeviceId  = $task.DeviceId
            Hostname  = $task.Hostname
            Command   = $task.Command
            Status    = $task.Status
            Error     = $task.Error
            Lines     = if ($task.OutputLines) { $task.OutputLines } else { @() }
            RawOutput = if ($task.CleanOutput) { $task.CleanOutput } else { "" }
        }
    }

    return $results
}

function Get-ConfigText {
    param(
        [object]$Response
    )

    if ($null -eq $Response) {
        return $null
    }

    if ($Response -is [string]) {
        return $Response
    }

    if ($Response.PSObject -and $Response.PSObject.Properties['response']) {
        return Get-ConfigText -Response $Response.response
    }

    if ($Response -is [System.Collections.IDictionary]) {
        try {
            return ($Response | ConvertTo-Json -Depth 10)
        } catch {
            $pairs = @()
            foreach ($entry in $Response.GetEnumerator()) {
                $pairs += "{0}: {1}" -f $entry.Key, $entry.Value
            }
            return ($pairs -join [Environment]::NewLine)
        }
    }

    if ($Response -is [System.Collections.IEnumerable]) {
        $buffer = @()
        foreach ($item in $Response) {
            if ($null -eq $item) { continue }

            if ($item -is [string]) {
                $buffer += $item
                continue
            }

            try {
                $buffer += ($item | ConvertTo-Json -Depth 10)
            } catch {
                $buffer += $item.ToString()
            }
        }

        if ($buffer.Count -eq 0) {
            return $null
        }

        return ($buffer -join [Environment]::NewLine)
    }

    try {
        return ($Response | ConvertTo-Json -Depth 10)
    } catch {
        return $Response.ToString()
    }
}

# NEW: Function to apply filters to output lines
function Apply-Filters {
    param(
        [string[]]$Lines,
        [string[]]$Filters
    )
    
    if ($Filters.Count -eq 0) {
        return $Lines
    }
    
    $matchedLines = @()
    foreach ($line in $Lines) {
        foreach ($pattern in $Filters) {
            # Use -like for simple substring matching (case-insensitive)
            if ($line -like "*$pattern*") {
                $matchedLines += $line
                break  # Stop checking other patterns once matched
            }
        }
    }
    
    return $matchedLines
}

function Get-TaskOutputDetails {
    param(
        [pscustomobject]$Task
    )

    $result = [ordered]@{
        CleanOutput       = ""
        OutputLines       = @()
        FilteredOutput    = ""
        FilteredLines     = @()
        OutputLineCount   = 0
        FilteredLineCount = 0
    }

    if (-not $Task -or $Task.Status -ne "Downloaded" -or $null -eq $Task.Output) {
        return [PSCustomObject]$result
    }

    $cleanOutput = ""
    $raw = $Task.Output

    if ($raw -is [string]) {
        $cleanOutput = $raw
    }
    elseif ($raw -is [array]) {
        foreach ($item in $raw) {
            if ($null -eq $item) { continue }

            $itemProps = $item.PSObject.Properties
            $commandKey = $itemProps | Where-Object { $_.Name -match "show" } | Select-Object -First 1

            if ($commandKey) {
                $rawOutput = $commandKey.Value
                if ($rawOutput -is [string]) {
                    $cleanOutput += $rawOutput
                }
                else {
                    $cleanOutput += ($rawOutput | ConvertTo-Json -Depth 10)
                }
            }
            elseif ($item.commandOutput) {
                $cleanOutput += $item.commandOutput
            }
            elseif ($item.output) {
                $cleanOutput += $item.output
            }
            else {
                $cleanOutput += ($item | ConvertTo-Json -Depth 10)
            }
        }
    }
    else {
        $outputProps = $raw.PSObject.Properties
        $commandKey = $outputProps | Where-Object { $_.Name -match "show" } | Select-Object -First 1

        if ($commandKey) {
            $rawOutput = $commandKey.Value
            if ($rawOutput -is [string]) {
                $cleanOutput = $rawOutput
            }
            else {
                $cleanOutput = ($rawOutput | ConvertTo-Json -Depth 10)
            }
        }
        elseif ($raw.commandOutput) {
            $cleanOutput = $raw.commandOutput
        }
        elseif ($raw.output) {
            $cleanOutput = $raw.output
        }
        else {
            $cleanOutput = ($raw | ConvertTo-Json -Depth 10)
        }
    }

    if ([string]::IsNullOrEmpty($cleanOutput)) {
        return [PSCustomObject]$result
    }

    $cleanOutput = $cleanOutput -replace '\\r\\n', "`n" -replace '\\r', "`n" -replace '\\n', "`n"
    $cleanOutput = $cleanOutput.Trim('"')
    $cleanOutput = $cleanOutput -replace '""', '"' -replace '\\`', '`' -replace '\\\\', '\'

    $outputLines = $cleanOutput -split "`r?`n" | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | ForEach-Object { $_.Trim() }

    $filteredLines = @()
    $filteredOutput = ""

    if ($Task.Filters -and $Task.Filters.Count -gt 0) {
        $filteredLines = Apply-Filters -Lines $outputLines -Filters $Task.Filters
        if ($filteredLines.Count -gt 0) {
            $filteredOutput = $filteredLines -join "`n"
        }
    }

    $result.CleanOutput = $outputLines -join "`n"
    $result.OutputLines = $outputLines
    $result.FilteredOutput = $filteredOutput
    $result.FilteredLines = $filteredLines
    $result.OutputLineCount = $outputLines.Count
    $result.FilteredLineCount = $filteredLines.Count

    return [PSCustomObject]$result
}

# =====================================================
# COMPLETE: Command Runner with Parallel Execution
# =====================================================
function Invoke-CommandRunner {
    param($headers, $dnaCenter)

    Clear-Host
    Write-Host ""
    Write-Host "╔═══════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "║           Command Runner - CLI Execution          ║" -ForegroundColor Cyan
    Write-Host "╚═══════════════════════════════════════════════════╝" -ForegroundColor Cyan
    Write-Host ""

    # Get devices to run command on
    $devices = Get-ActiveDevices

    if (-not $devices) {
        Read-Host "`nPress Enter to continue"
        return
    }

    Write-Host "Current device selection: $($devices.Count) device(s)" -ForegroundColor Yellow
    Write-Host ""

    # Ask for output format preference
    Write-Host "Choose output format:" -ForegroundColor Yellow
    Write-Host "1. Separate files per hostname (recommended for large outputs)" -ForegroundColor White
    Write-Host "2. Single CSV with all results (good for analysis)" -ForegroundColor White
    Write-Host "3. Both formats" -ForegroundColor White
    Write-Host "4. Both formats + Concatenated text file" -ForegroundColor White
    Write-Host ""
    $outputFormat = Read-Host "Select option (1/2/3/4)"

    $useSeparateFiles = $false
    $useConsolidatedCSV = $false
    $useConcatenatedText = $false

    switch ($outputFormat) {
        "1" { $useSeparateFiles = $true }
        "2" { $useConsolidatedCSV = $true }
        "3" {
            $useSeparateFiles = $true
            $useConsolidatedCSV = $true
        }
        "4" {
            $useSeparateFiles = $true
            $useConsolidatedCSV = $true
            $useConcatenatedText = $true
        }
        default {
            Write-Host "Invalid option. Using separate files per hostname." -ForegroundColor Yellow
            $useSeparateFiles = $true
        }
    }

    Write-Host ""
    if ($useSeparateFiles -and $useConsolidatedCSV -and $useConcatenatedText) {
        Write-Host "✓ Will generate separate files, consolidated CSV, and concatenated text file" -ForegroundColor Green
    }
    elseif ($useSeparateFiles -and $useConsolidatedCSV) {
        Write-Host "✓ Will generate both separate files and consolidated CSV" -ForegroundColor Green
    }
    elseif ($useSeparateFiles) {
        Write-Host "✓ Will generate separate files per hostname" -ForegroundColor Green
    }
    else {
        Write-Host "✓ Will generate consolidated CSV with all results" -ForegroundColor Green
    }
    Write-Host ""

    # Get command(s) to execute with per-command filters
    Write-Host ""
    Write-Host "Enter CLI command(s) to execute:" -ForegroundColor Yellow
    Write-Host "(For multiple commands, enter one per line. Type 'DONE' when finished)" -ForegroundColor DarkGray
    Write-Host ""
    Write-Host "  NOTE: Pipes (|) are NOT supported by DNA Center API" -ForegroundColor Yellow
    Write-Host "   Use plain commands only. Filtering will be done after." -ForegroundColor DarkGray
    Write-Host ""
    Write-Host "FILTERING INSTRUCTIONS:" -ForegroundColor Magenta
    Write-Host "  • Filters match partial text in output lines" -ForegroundColor Gray
    Write-Host "  • Matching is case-insensitive" -ForegroundColor Gray
    Write-Host "  • No special regex syntax needed - just enter text to find" -ForegroundColor Gray
    Write-Host "  • Prompts accept yes/y or no/n" -ForegroundColor Gray
    Write-Host ""
    Write-Host "Examples:" -ForegroundColor DarkGray
    Write-Host "  Command: show ip interface brief" -ForegroundColor DarkGray
    Write-Host "  Filter for this command? (y/yes = filter): yes" -ForegroundColor DarkGray
    Write-Host "  Filter 1: up" -ForegroundColor DarkGray
    Write-Host "  Filter 2: Gigabit" -ForegroundColor DarkGray
    Write-Host "  Filter 3: 10.1.1." -ForegroundColor DarkGray
    Write-Host "  Filter 4: DONE" -ForegroundColor DarkGray
    Write-Host "  Next command: show version" -ForegroundColor DarkGray
    Write-Host "  Filter for this command? (y/yes = filter): no" -ForegroundColor DarkGray
    Write-Host "  DONE (to finish entering commands)" -ForegroundColor DarkGray
    Write-Host ""

    $commands = @()
    $commandNumber = 1

    while ($true) {
        Write-Host ""
        Write-Host "--- Command $commandNumber ---" -ForegroundColor Cyan
        $command = Read-Host "Enter command (or type DONE)"

        if ($command.ToUpper() -eq "DONE") {
            break
        }

        if (-not [string]::IsNullOrWhiteSpace($command)) {
            # Check for unsupported characters
            $cleanCommand = $command
            if ($command -match '\|') {
                Write-Host "    Warning: Pipes (|) detected - removing filter. Will apply after." -ForegroundColor Yellow
                Write-Host "     Original: $command" -ForegroundColor DarkGray

                # Extract base command (before pipe)
                $cleanCommand = ($command -split '\|')[0].Trim()
                Write-Host "     Using: $cleanCommand" -ForegroundColor Green
            }

            # Ask if user wants to filter THIS specific command
            $commandFilters = @()
            $filterChoice = Read-Host "Filter output for this command? (y/yes to add filters, anything else skips)"
            $filterChoiceNormalized = if ($null -ne $filterChoice) { $filterChoice.Trim().ToLower() } else { "" }

            if ($filterChoiceNormalized -in @("y", "yes")) {
                Write-Host ""
                Write-Host "Enter filter patterns for '$cleanCommand' (one per line, type DONE when finished):" -ForegroundColor Yellow
                Write-Host "  • Enter text to match in output lines" -ForegroundColor Gray
                Write-Host "  • Examples: 'Gig0/1', 'up', '192.168.1.', 'TenGig'" -ForegroundColor Gray
                Write-Host ""
                $filterNumber = 1
                while ($true) {
                    $pattern = Read-Host "  Filter $filterNumber (or DONE)"
                    if ($pattern.ToUpper() -eq "DONE") {
                        break
                    }
                    if (-not [string]::IsNullOrWhiteSpace($pattern)) {
                        $commandFilters += $pattern.Trim()
                        $filterNumber++
                    }
                }
            }

            # Store command with its specific filters
            $commands += [PSCustomObject]@{
                Command = $cleanCommand
                Filters = $commandFilters
            }

            Write-Host "  ✓ Added command: $cleanCommand" -ForegroundColor Green
            if ($commandFilters.Count -gt 0) {
                Write-Host "  ✓ With $($commandFilters.Count) filter(s): $($commandFilters -join ', ')" -ForegroundColor Yellow
            }

            $commandNumber++
        }
    }

    if ($commands.Count -eq 0) {
        Write-Host "`n✗ No commands entered" -ForegroundColor Red
        Read-Host "`nPress Enter to continue"
        return
    }

    Write-Host ""
    Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
    Write-Host "Summary of commands to execute:" -ForegroundColor Cyan
    Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
    for ($i = 0; $i -lt $commands.Count; $i++) {
        Write-Host "$($i+1). $($commands[$i].Command)" -ForegroundColor White
        if ($commands[$i].Filters.Count -gt 0) {
            Write-Host "   Filters: $($commands[$i].Filters -join ', ')" -ForegroundColor Yellow
        }
        else {
            Write-Host "   No filters" -ForegroundColor Gray
        }
    }
    Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
    Write-Host "On $($devices.Count) device(s)" -ForegroundColor Cyan
    Write-Host ""

    $confirm = Read-Host "Proceed? (y/yes to continue, anything else cancels)"
    $confirmNormalized = if ($null -ne $confirm) { $confirm.Trim().ToLower() } else { "" }
    if ($confirmNormalized -notin @("y", "yes")) {
        Write-Host "✗ Operation cancelled" -ForegroundColor Yellow
        Read-Host "`nPress Enter to continue"
        return
    }

    Write-Host "`nSubmitting all commands to DNA Center..." -ForegroundColor Yellow

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $outputFolder = "$outputDir\CommandRunner_$timestamp"
    New-Item -ItemType Directory -Path $outputFolder -Force | Out-Null

    # Track all tasks
    $taskTracker = @()

    # PHASE 1: Submit ALL commands for ALL devices
    Write-Host ""
    Write-Host "Phase 1: Submitting commands..." -ForegroundColor Cyan
    $submitCounter = 0
    $totalSubmissions = $devices.Count * $commands.Count

    foreach ($device in $devices) {
        $hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
        $deviceId = $device.id

        foreach ($cmdObj in $commands) {
            $submitCounter++
            Show-ProgressBar -Current $submitCounter -Total $totalSubmissions -Activity "$hostname : $($cmdObj.Command)"

            $requestBody = @{
                "name"       = "Cmd-$hostname-$(Get-Random)"
                "commands"   = @($cmdObj.Command)
                "deviceUuids" = @($deviceId)
            } | ConvertTo-Json -Depth 10

            try {
                $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/network-device-poller/cli/read-request" `
                    -Method Post `
                    -Headers $headers `
                    -Body $requestBody `
                    -ContentType "application/json"

                if ($response -and $response.response -and $response.response.taskId) {
                    $taskTracker += [PSCustomObject]@{
                        TaskId     = $response.response.taskId
                        Hostname   = $hostname
                        DeviceId   = $deviceId
                        DeviceIP   = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                        Command    = $cmdObj.Command
                        Status     = "Submitted"
                        FileId     = $null
                        Output     = $null
                        RawOutput  = $null
                        SubmitTime = Get-Date
                        Filters    = $cmdObj.Filters
                    }
                }
                else {
                    $taskTracker += [PSCustomObject]@{
                        TaskId     = $null
                        Hostname   = $hostname
                        DeviceId   = $deviceId
                        DeviceIP   = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                        Command    = $cmdObj.Command
                        Status     = "Submit Failed"
                        FileId     = $null
                        Output     = $null
                        RawOutput  = $null
                        SubmitTime = Get-Date
                        Filters    = $cmdObj.Filters
                    }
                }
            }
            catch {
                $errorMsg = $_.Exception.Message
                if ($_.ErrorDetails.Message) {
                    try {
                        $errorObj = $_.ErrorDetails.Message | ConvertFrom-Json
                        if ($errorObj.response -and $errorObj.response.message) {
                            $errorMsg = $errorObj.response.message
                        }
                    }
                    catch {
                        $errorMsg = $_.ErrorDetails.Message
                    }
                }

                $taskTracker += [PSCustomObject]@{
                    TaskId     = $null
                    Hostname   = $hostname
                    DeviceId   = $deviceId
                    DeviceIP   = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                    Command    = $cmdObj.Command
                    Status     = "Error: $errorMsg"
                    FileId     = $null
                    Output     = $null
                    RawOutput  = $null
                    SubmitTime = Get-Date
                    Filters    = $cmdObj.Filters
                }
            }

            # Small delay to avoid overwhelming the API
            Start-Sleep -Milliseconds 100
        }
    }

    Write-Host "`n"
    Write-Host "✓ Submitted $submitCounter command(s)" -ForegroundColor Green
    Write-Host ""

    # PHASE 2: Poll ALL tasks until they complete
    Write-Host "Phase 2: Waiting for all tasks to complete..." -ForegroundColor Cyan
    Write-Host "(This may take 1-3 minutes depending on device count)" -ForegroundColor DarkGray

    $maxWaitTime = 300  # 5 minutes total
    $startTime = Get-Date
    $checkInterval = 3  # Check every 3 seconds

    $pendingTasks = $taskTracker | Where-Object { $_.TaskId -and $_.Status -eq "Submitted" }

    while ($pendingTasks.Count -gt 0) {
        $elapsed = ((Get-Date) - $startTime).TotalSeconds

        if ($elapsed -gt $maxWaitTime) {
            Write-Host "`n! Timeout reached - some tasks may still be running" -ForegroundColor Yellow
            break
        }

        # Check status of all pending tasks
        foreach ($task in $pendingTasks) {
            try {
                $taskResponse = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/task/$($task.TaskId)" `
                    -Method Get `
                    -Headers $headers

                if ($taskResponse -and $taskResponse.response) {
                    $taskInfo = $taskResponse.response

                    # Check if completed
                    if ($taskInfo.isError) {
                        $task.Status = "Failed"
                    }
                    elseif ($taskInfo.endTime) {
                        $task.Status = "Completed"

                        # Extract file ID
                        if ($taskInfo.additionalStatusURL -and $taskInfo.additionalStatusURL -match '/file/([a-f0-9\-]+)') {
                            $task.FileId = $Matches[1]
                        }
                        elseif ($taskInfo.progress) {
                            try {
                                $progressData = $taskInfo.progress | ConvertFrom-Json
                                if ($progressData.fileId) {
                                    $task.FileId = $progressData.fileId
                                }
                            }
                            catch {
                                if ($taskInfo.progress -match '"fileId"\s*:\s*"([^"]+)"') {
                                    $task.FileId = $Matches[1]
                                }
                            }
                        }
                    }
                }
            }
            catch {
                # Keep trying
            }
        }

        # Update pending list
        $pendingTasks = $taskTracker | Where-Object { $_.Status -eq "Submitted" }

        # Show progress
        $completedCount = ($taskTracker | Where-Object { $_.Status -in @("Completed", "Failed") }).Count
        $totalCount = $taskTracker.Count
        $percentComplete = [math]::Round(($completedCount / $totalCount) * 100)

        Write-Host "`r  Progress: $completedCount/$totalCount tasks completed ($percentComplete%) - Elapsed: $([math]::Round($elapsed))s" -NoNewline -ForegroundColor Cyan

        if ($pendingTasks.Count -gt 0) {
            Start-Sleep -Seconds $checkInterval
        }
    }

    Write-Host "`n"
    Write-Host "✓ All tasks completed!" -ForegroundColor Green
    Write-Host ""

    # PHASE 3: Download outputs
    Write-Host "Phase 3: Downloading outputs..." -ForegroundColor Cyan

    $completedTasks = $taskTracker | Where-Object { $_.Status -eq "Completed" -and $_.FileId }
    $downloadCounter = 0

    Write-Host ""
    foreach ($task in $completedTasks) {
        $downloadCounter++
        Show-ProgressBar -Current $downloadCounter -Total $completedTasks.Count -Activity "$($task.Hostname)"

        try {
            $fileResponse = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/file/$($task.FileId)" `
                -Method Get `
                -Headers $headers

            $task.Status = "Downloaded"
            $task.Output = $fileResponse
            $task.RawOutput = $fileResponse  # Keep raw output for JSON

        }
        catch {
            $task.Status = "Download Failed"
        }
    }

    Write-Host "`n"

    # PHASE 4: Create output files based on user preference
    Write-Host "Phase 4: Creating output files..." -ForegroundColor Cyan

    $summaryList = @()
    $consolidatedData = @()  # For CSV output

    foreach ($task in $taskTracker) {
        $details = Get-TaskOutputDetails -Task $task
        $task | Add-Member -NotePropertyName "CleanOutput" -NotePropertyValue $details.CleanOutput -Force
        $task | Add-Member -NotePropertyName "OutputLines" -NotePropertyValue $details.OutputLines -Force
        $task | Add-Member -NotePropertyName "FilteredOutput" -NotePropertyValue $details.FilteredOutput -Force
        $task | Add-Member -NotePropertyName "FilteredLines" -NotePropertyValue $details.FilteredLines -Force
        $task | Add-Member -NotePropertyName "OutputLineCount" -NotePropertyValue $details.OutputLineCount -Force
        $task | Add-Member -NotePropertyName "FilteredLineCount" -NotePropertyValue $details.FilteredLineCount -Force
    }

    # Process tasks for consolidated CSV if requested
    if ($useConsolidatedCSV) {
        Write-Host "Preparing consolidated CSV data..." -ForegroundColor Cyan

        foreach ($task in $taskTracker) {
            $cleanOutput = $task.CleanOutput
            $filteredOutput = $task.FilteredOutput

            $filteredDisplay = if ($task.FilteredLineCount -gt 0) {
                $filteredOutput
            }
            elseif ($task.Filters.Count -gt 0) {
                "No matches found"
            }
            else {
                "N/A"
            }

            $consolidatedData += [PSCustomObject]@{
                Hostname          = $task.Hostname
                DeviceIP          = $task.DeviceIP
                Command           = $task.Command
                Status            = $task.Status
                ExecutionTime     = $task.SubmitTime.ToString("yyyy-MM-dd HH:mm:ss")
                Filters           = if ($task.Filters.Count -gt 0) { $task.Filters -join ", " } else { "None" }
                Output            = $cleanOutput
                FilteredOutput    = $filteredDisplay
                OutputLineCount   = $task.OutputLineCount
                FilteredLineCount = $task.FilteredLineCount
            }
        }

        # Export consolidated CSV
        $consolidatedCSVPath = "$outputDir\CommandRunner_AllResults_$timestamp.csv"
        $consolidatedData | Export-Csv -Path $consolidatedCSVPath -NoTypeInformation
        Write-Host "✓ Created consolidated CSV: $consolidatedCSVPath" -ForegroundColor Green
    }

    # Create separate files if requested
    if ($useSeparateFiles) {
        $deviceGroups = $taskTracker | Group-Object -Property Hostname

        foreach ($deviceGroup in $deviceGroups) {
            $hostname = $deviceGroup.Name
            $deviceTasks = $deviceGroup.Group

            $safeHostname = $hostname -replace '[\\/:*?"<>|]', '_'

            # Create JSON data structure
            $jsonData = @{
                Device        = $hostname
                DeviceIP      = $deviceTasks[0].DeviceIP
                ExecutionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                Commands      = @()
            }

            # Full output with clean formatting
            $fullOutputFile = "$outputFolder\${safeHostname}_output_full.txt"
            $fullLines = @()

            $fullLines += "=" * 80
            $fullLines += "Device: $hostname"
            $fullLines += "IP Address: $($deviceTasks[0].DeviceIP)"
            $fullLines += "Total Commands: $($deviceTasks.Count)"
            $fullLines += "Execution Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
            $fullLines += "=" * 80
            $fullLines += ""

            $successCount = 0
            $failCount = 0

            # Check if ANY command has filters
            $hasFilters = ($deviceTasks | Where-Object { $_.Filters.Count -gt 0 }).Count -gt 0
            $filteredLines = @()

            if ($hasFilters) {
                $filteredLines += "=" * 80
                $filteredLines += "Device: $hostname (FILTERED RESULTS)"
                $filteredLines += "IP Address: $($deviceTasks[0].DeviceIP)"
                $filteredLines += "=" * 80
                $filteredLines += ""
            }

            foreach ($task in $deviceTasks) {
                $commandInfo = @{
                    Command       = $task.Command
                    Status        = $task.Status
                    Filters       = $task.Filters
                    ExecutionTime = $task.SubmitTime.ToString("yyyy-MM-dd HH:mm:ss")
                }

                $fullLines += ""
                $fullLines += "=" * 80
                $fullLines += "Command: $($task.Command)"
                $fullLines += "Status: $($task.Status)"
                $fullLines += "Execution Time: $($task.SubmitTime.ToString('yyyy-MM-dd HH:mm:ss'))"
                if ($task.Filters.Count -gt 0) {
                    $fullLines += "Filters: $($task.Filters -join ', ')"
                }
                $fullLines += "=" * 80
                $fullLines += ""

                if ($task.Status -eq "Downloaded" -and $null -ne $task.Output) {
                    if ($task.OutputLineCount -gt 0) {
                        $fullLines += $task.OutputLines
                    }
                    else {
                        $fullLines += "(No output returned from device)"
                    }
                    $fullLines += ""
                    $successCount++

                    $commandInfo | Add-Member -NotePropertyName "Output" -NotePropertyValue $task.CleanOutput
                    $commandInfo | Add-Member -NotePropertyName "RawOutput" -NotePropertyValue $task.RawOutput
                    $commandInfo | Add-Member -NotePropertyName "Success" -NotePropertyValue $true

                    if ($task.Filters.Count -gt 0) {
                        $filteredLines += ""
                        $filteredLines += "-" * 80
                        $filteredLines += "Command: $($task.Command)"
                        $filteredLines += "Filters: $($task.Filters -join ', ')"
                        $filteredLines += "-" * 80
                        $filteredLines += ""

                        if ($task.FilteredLineCount -gt 0) {
                            $filteredLines += $task.FilteredLines
                            $filteredLines += ""
                            $filteredLines += "  ✓ Matched $($task.FilteredLineCount) line(s)"

                            $commandInfo | Add-Member -NotePropertyName "FilteredOutput" -NotePropertyValue $task.FilteredOutput
                            $commandInfo | Add-Member -NotePropertyName "FilteredLineCount" -NotePropertyValue $task.FilteredLineCount
                        }
                        else {
                            $filteredLines += "    No matches found"
                            $commandInfo | Add-Member -NotePropertyName "FilteredOutput" -NotePropertyValue "No matches found"
                            $commandInfo | Add-Member -NotePropertyName "FilteredLineCount" -NotePropertyValue 0
                        }
                    }
                }
                else {
                    $fullLines += "ERROR: $($task.Status)"
                    $fullLines += ""
                    $failCount++

                    $commandInfo | Add-Member -NotePropertyName "Error" -NotePropertyValue $task.Status
                    $commandInfo | Add-Member -NotePropertyName "Success" -NotePropertyValue $false

                    if ($task.Filters.Count -gt 0) {
                        $filteredLines += ""
                        $filteredLines += "-" * 80
                        $filteredLines += "Command: $($task.Command)"
                        $filteredLines += "-" * 80
                        $filteredLines += "ERROR: $($task.Status)"
                        $filteredLines += ""
                    }
                }

                $jsonData.Commands += $commandInfo
            }

            # Save text files
            $fullLines | Out-File -FilePath $fullOutputFile -Encoding UTF8

            $filteredOutputFile = $null
            if ($hasFilters) {
                $filteredOutputFile = "$outputFolder\${safeHostname}_output_filtered.txt"
                $filteredLines | Out-File -FilePath $filteredOutputFile -Encoding UTF8
            }

            # Save JSON file with increased depth to capture all output
            $jsonFile = "$outputFolder\${safeHostname}_output.json"
            
            # DEBUG: Check what we're about to save
            $commandsWithOutput = $jsonData.Commands | Where-Object { $_.Output }
            $commandsWithFiltered = $jsonData.Commands | Where-Object { $_.FilteredOutput -and $_.FilteredOutput -ne "No matches found" }
            
            Write-Host "  Device: $hostname - Commands with output: $($commandsWithOutput.Count), with filtered: $($commandsWithFiltered.Count)" -ForegroundColor Gray
            
            $jsonData | ConvertTo-Json -Depth 20 | Out-File -FilePath $jsonFile -Encoding UTF8

            # Build summary
            $filterSummary = @()
            foreach ($task in $deviceTasks) {
                if ($task.Filters.Count -gt 0) {
                    $filterSummary += "$($task.Command): [$($task.Filters -join ', ')]"
                }
            }

            $summaryList += [PSCustomObject]@{
                Hostname           = $hostname
                DeviceIP           = $deviceTasks[0].DeviceIP
                TotalCommands      = $deviceTasks.Count
                SuccessfulCommands = $successCount
                FailedCommands     = $failCount
                CommandList        = (($deviceTasks | Select-Object -ExpandProperty Command) -join "; ")
                FiltersApplied     = if ($filterSummary.Count -gt 0) { $filterSummary -join " | " } else { "None" }
                Status             = if ($failCount -eq 0) { "All Success" } elseif ($successCount -eq 0) { "All Failed" } else { "Partial" }
                FullOutputFile     = if ($useSeparateFiles) { $fullOutputFile } else { "N/A" }
                FilteredOutputFile = if ($filteredOutputFile) { $filteredOutputFile } else { "N/A" }
                JsonFile           = if ($useSeparateFiles) { $jsonFile } else { "N/A" }
                ExecutionTime      = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            }
        }
    }

    $filterEnabledTasks = $taskTracker | Where-Object { $_.Filters -and $_.Filters.Count -gt 0 }
    if ($filterEnabledTasks.Count -gt 0) {
        $filteredSummaryLines = @()
        $filteredSummaryLines += "=" * 100
        $filteredSummaryLines += "DNA CENTER COMMAND RUNNER - FILTERED OUTPUT ONLY"
        $filteredSummaryLines += "Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        $filteredSummaryLines += "Total Devices With Filters: $(( $filterEnabledTasks | Select-Object -ExpandProperty Hostname -Unique ).Count)"
        $filteredSummaryLines += "Total Commands With Filters: $($filterEnabledTasks.Count)"
        $filteredSummaryLines += "=" * 100
        $filteredSummaryLines += ""

        foreach ($deviceGroup in ($filterEnabledTasks | Group-Object -Property Hostname)) {
            $filteredSummaryLines += ""
            $filteredSummaryLines += "#" * 80
            $filteredSummaryLines += "DEVICE: $($deviceGroup.Name)"
            $filteredSummaryLines += "IP: $($deviceGroup.Group[0].DeviceIP)"
            $filteredSummaryLines += "#" * 80
            $filteredSummaryLines += ""

            foreach ($task in $deviceGroup.Group) {
                $filteredSummaryLines += "-" * 60
                $filteredSummaryLines += "Command: $($task.Command)"
                $filteredSummaryLines += "Filters: $($task.Filters -join ', ')"
                $filteredSummaryLines += "Status: $($task.Status)"
                $filteredSummaryLines += "-" * 60

                if ($task.Status -eq "Downloaded" -and $task.FilteredLineCount -gt 0) {
                    $filteredSummaryLines += $task.FilteredLines
                }
                elseif ($task.Status -eq "Downloaded") {
                    $filteredSummaryLines += "  No matches found for the specified filters."
                }
                else {
                    $filteredSummaryLines += "  ERROR: $($task.Status)"
                }

                $filteredSummaryLines += ""
            }
        }

        $filteredSummaryFile = "$outputFolder\ALL_DEVICES_FILTERED_OUTPUT.txt"
        $filteredSummaryLines | Out-File -FilePath $filteredSummaryFile -Encoding UTF8
        Write-Host "✓ Created filtered text file: $filteredSummaryFile" -ForegroundColor Green

        $filteredCsvData = foreach ($task in $filterEnabledTasks) {
            [PSCustomObject]@{
                Hostname         = $task.Hostname
                DeviceIP         = $task.DeviceIP
                Command          = $task.Command
                FiltersApplied   = $task.Filters -join ", "
                Status           = $task.Status
                MatchedLineCount = $task.FilteredLineCount
                FilteredOutput   = if ($task.FilteredLineCount -gt 0) { $task.FilteredOutput } elseif ($task.Status -eq "Downloaded") { "No matches found" } else { "ERROR: $($task.Status)" }
            }
        }

        $filteredCsvPath = "$outputDir\CommandRunner_FilteredOnly_$timestamp.csv"
        $filteredCsvData | Export-Csv -Path $filteredCsvPath -NoTypeInformation
        Write-Host "✓ Created filtered CSV: $filteredCsvPath" -ForegroundColor Green
    }

    # Create concatenated text file if requested
    if ($useConcatenatedText -and $useSeparateFiles) {
        Write-Host "Creating concatenated text file..." -ForegroundColor Cyan
        
        $concatenatedFile = "$outputFolder\ALL_DEVICES_OUTPUT_CONCATENATED.txt"
        $concatenatedLines = @()
        
        # Also prepare CSV version of concatenated output
        $concatenatedCSVData = @()
        
        $concatenatedLines += "=" * 100
        $concatenatedLines += "DNA CENTER COMMAND RUNNER - ALL DEVICES CONCATENATED OUTPUT"
        $concatenatedLines += "Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
        $concatenatedLines += "Total Devices: $($deviceGroups.Count)"
        $concatenatedLines += "Total Commands: $($commands.Count)"
        $concatenatedLines += "=" * 100
        $concatenatedLines += ""
        
        foreach ($deviceGroup in $deviceGroups) {
            $hostname = $deviceGroup.Name
            $deviceTasks = $deviceGroup.Group
            
            $concatenatedLines += ""
            $concatenatedLines += "#" * 80
            $concatenatedLines += "DEVICE: $hostname"
            $concatenatedLines += "IP: $($deviceTasks[0].DeviceIP)"
            $concatenatedLines += "#" * 80
            $concatenatedLines += ""
            
            foreach ($task in $deviceTasks) {
                $concatenatedLines += ""
                $concatenatedLines += "-" * 60
                $concatenatedLines += "Command: $($task.Command)"
                $concatenatedLines += "Status: $($task.Status)"
                if ($task.Filters.Count -gt 0) {
                    $concatenatedLines += "Filters Applied: $($task.Filters -join ', ')"
                }
                $concatenatedLines += "-" * 60
                $concatenatedLines += ""
                
                if ($task.Status -eq "Downloaded" -and $null -ne $task.Output) {
                    # Parse and clean output (comprehensive logic)
                    $cleanOutput = ""
                    if ($task.Output -is [string]) {
                        $cleanOutput = $task.Output -replace '\\n', "`n" -replace '\\r\\n', "`n" -replace '\\r', "`n"
                    }
                    elseif ($task.Output -is [array]) {
                        foreach ($item in $task.Output) {
                            $itemProps = $item.PSObject.Properties
                            $commandKey = $itemProps | Where-Object { $_.Name -match "show" } | Select-Object -First 1
                            if ($commandKey) {
                                $rawOutput = $commandKey.Value
                                if ($rawOutput -is [string]) {
                                    $cleanOutput += $rawOutput -replace '\\n', "`n" -replace '\\r\\n', "`n" -replace '\\r', "`n"
                                }
                                else {
                                    $cleanOutput += ($rawOutput | ConvertTo-Json -Depth 10) -replace '\\n', "`n" -replace '\\r\\n', "`n"
                                }
                            }
                            elseif ($item.commandOutput) {
                                $cleanOutput += $item.commandOutput -replace '\\n', "`n" -replace '\\r\\n', "`n" -replace '\\r', "`n"
                            }
                            elseif ($item.output) {
                                $cleanOutput += $item.output -replace '\\n', "`n" -replace '\\r\\n', "`n" -replace '\\r', "`n"
                            }
                            else {
                                $cleanOutput += ($item | ConvertTo-Json -Depth 10) -replace '\\n', "`n" -replace '\\r\\n', "`n"
                            }
                        }
                    }
                    else {
                        # Handle object output
                        $outputProps = $task.Output.PSObject.Properties
                        $commandKey = $outputProps | Where-Object { $_.Name -match "show" } | Select-Object -First 1
                        
                        if ($commandKey) {
                            $rawOutput = $commandKey.Value
                            if ($rawOutput -is [string]) {
                                $cleanOutput = $rawOutput -replace '\\n', "`n" -replace '\\r\\n', "`n" -replace '\\r', "`n"
                            }
                            else {
                                $cleanOutput = ($rawOutput | ConvertTo-Json -Depth 10) -replace '\\n', "`n" -replace '\\r\\n', "`n"
                            }
                        }
                        elseif ($task.Output.commandOutput) {
                            $cleanOutput = $task.Output.commandOutput -replace '\\n', "`n" -replace '\\r\\n', "`n" -replace '\\r', "`n"
                        }
                        elseif ($task.Output.output) {
                            $cleanOutput = $task.Output.output -replace '\\n', "`n" -replace '\\r\\n', "`n" -replace '\\r', "`n"
                        }
                        else {
                            $cleanOutput = ($task.Output | ConvertTo-Json -Depth 10) -replace '\\n', "`n" -replace '\\r\\n', "`n"
                        }
                    }
                    
                    $cleanOutput = $cleanOutput.Trim('"')
                    $cleanOutput = $cleanOutput -replace '""', '"' -replace '\\`', '`' -replace '\\\\', '\'
                    $outputLines = $cleanOutput -split "`r?`n" | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | ForEach-Object { $_.Trim() }
                    
                    # Apply filters if any
                    $displayOutput = ""
                    $filterNote = ""
                    if ($task.Filters.Count -gt 0) {
                        $matchedLines = Apply-Filters -Lines $outputLines -Filters $task.Filters
                        if ($matchedLines.Count -gt 0) {
                            $concatenatedLines += $matchedLines
                            $displayOutput = $matchedLines -join "`n"
                            $filterNote = "FILTERED: Showed $($matchedLines.Count) matching lines from $($outputLines.Count) total"
                            $concatenatedLines += ""
                            $concatenatedLines += "  [$filterNote]"
                        }
                        else {
                            $filterNote = "NO MATCHES: No lines matched the filter(s): $($task.Filters -join ', ')"
                            $concatenatedLines += "  [$filterNote]"
                            $displayOutput = ""
                        }
                    }
                    else {
                        # No filters - show all output
                        if ($outputLines.Count -gt 0) {
                            $concatenatedLines += $outputLines
                            $displayOutput = $outputLines -join "`n"
                        }
                        else {
                            $concatenatedLines += "  (No output lines returned)"
                            $displayOutput = "(No output lines returned)"
                        }
                    }
                    
                    # Add to CSV data
                    $concatenatedCSVData += [PSCustomObject]@{
                        Hostname        = $hostname
                        DeviceIP        = $task.DeviceIP
                        Command         = $task.Command
                        Status          = $task.Status
                        FiltersApplied  = if ($task.Filters.Count -gt 0) { $task.Filters -join ", " } else { "None" }
                        FilterNote      = $filterNote
                        FullOutput      = $outputLines -join "`n"
                        DisplayedOutput = $displayOutput
                        TotalLines      = $outputLines.Count
                        DisplayedLines  = if ($displayOutput) { ($displayOutput -split "`n").Count } else { 0 }
                        ExecutionTime   = $task.SubmitTime.ToString("yyyy-MM-dd HH:mm:ss")
                    }
                }
                else {
                    $concatenatedLines += "ERROR: $($task.Status)"
                    
                    # Add error to CSV data
                    $concatenatedCSVData += [PSCustomObject]@{
                        Hostname        = $hostname
                        DeviceIP        = $task.DeviceIP
                        Command         = $task.Command
                        Status          = $task.Status
                        FiltersApplied  = if ($task.Filters.Count -gt 0) { $task.Filters -join ", " } else { "None" }
                        FilterNote      = "ERROR"
                        FullOutput      = ""
                        DisplayedOutput = ""
                        TotalLines      = 0
                        DisplayedLines  = 0
                        ExecutionTime   = $task.SubmitTime.ToString("yyyy-MM-dd HH:mm:ss")
                    }
                }
                $concatenatedLines += ""
            }
        }
        
        # Save text file
        $concatenatedLines | Out-File -FilePath $concatenatedFile -Encoding UTF8
        Write-Host "✓ Created concatenated text file: $concatenatedFile" -ForegroundColor Green
        
        # Save CSV version
        $concatenatedCSVFile = "$outputFolder\ALL_DEVICES_OUTPUT_CONCATENATED.csv"
        $concatenatedCSVData | Export-Csv -Path $concatenatedCSVFile -NoTypeInformation
        Write-Host "✓ Created concatenated CSV file: $concatenatedCSVFile" -ForegroundColor Green
    }

    # Export summary
    $csvPath = "$outputDir\CommandRunner_Summary_$timestamp.csv"
    $summaryList | Export-Csv -Path $csvPath -NoTypeInformation

    Write-Host ""
    Write-Host "═══════════════════════════════════════" -ForegroundColor Green
    Write-Host "Command Runner Complete!" -ForegroundColor Green
    Write-Host "═══════════════════════════════════════" -ForegroundColor Green
    Write-Host "Summary: $csvPath" -ForegroundColor Cyan
    Write-Host "Outputs: $outputFolder" -ForegroundColor Cyan
    Write-Host ""
    
    # Filter statistics
    $tasksWithFilters = $taskTracker | Where-Object { $_.Filters -and $_.Filters.Count -gt 0 }
    $tasksWithOutput = $taskTracker | Where-Object { $_.Status -eq "Downloaded" -and $null -ne $_.Output }
    Write-Host "Execution Statistics:" -ForegroundColor Cyan
    Write-Host "  Total tasks: $($taskTracker.Count)" -ForegroundColor White
    Write-Host "  Successfully downloaded: $($tasksWithOutput.Count)" -ForegroundColor Green
    Write-Host "  Tasks with filters: $($tasksWithFilters.Count)" -ForegroundColor Yellow
    if ($tasksWithFilters.Count -gt 0) {
        Write-Host "  Filter details:" -ForegroundColor Yellow
        foreach ($task in $tasksWithFilters) {
            Write-Host "    - $($task.Hostname): $($task.Command) [Filters: $($task.Filters -join ', ')]" -ForegroundColor Gray
        }
    }
    Write-Host ""

    if ($useConsolidatedCSV) {
        Write-Host "Consolidated Files:" -ForegroundColor Cyan
        Write-Host "  - CommandRunner_AllResults_$timestamp.csv (all results in one file)" -ForegroundColor White
        Write-Host ""
    }

    if ($useConcatenatedText) {
        Write-Host "Concatenated Files:" -ForegroundColor Cyan
        Write-Host "  - ALL_DEVICES_OUTPUT_CONCATENATED.txt (all devices in one text file)" -ForegroundColor White
        Write-Host "  - ALL_DEVICES_OUTPUT_CONCATENATED.csv (all devices in one CSV file)" -ForegroundColor White
        Write-Host ""
    }

    if ($useSeparateFiles) {
        Write-Host "Files per device:" -ForegroundColor Cyan
        Write-Host "  - *_output_full.txt (clean formatted output)" -ForegroundColor White
        if (($taskTracker | Where-Object { $_.Filters.Count -gt 0 }).Count -gt 0) {
            Write-Host "  - *_output_filtered.txt (filtered results)" -ForegroundColor Yellow
        }
        Write-Host "  - *_output.json (raw data in JSON format)" -ForegroundColor Magenta
        Write-Host ""
    }

    if ($tasksWithFilters.Count -gt 0) {
        Write-Host "Filtered result files:" -ForegroundColor Cyan
        Write-Host "  - ALL_DEVICES_FILTERED_OUTPUT.txt (all filtered matches in one file)" -ForegroundColor Yellow
        Write-Host "  - CommandRunner_FilteredOnly_$timestamp.csv (filtered summary across devices)" -ForegroundColor Yellow
        Write-Host ""
    }

    Write-Host ""
    Read-Host "Press Enter to continue"
}

# =====================================================
# ENHANCED: Path Trace - Network Path Analysis
# =====================================================
function Invoke-PathTrace {
    param($headers, $dnaCenter)
    
    Clear-Host
    Write-Host ""
    Write-Host "╔═══════════════════════════════════════════════════╗" -ForegroundColor Cyan
    Write-Host "║         Path Trace - Network Path Analysis        ║" -ForegroundColor Cyan
    Write-Host "╚═══════════════════════════════════════════════════╝" -ForegroundColor Cyan
    Write-Host ""
    
    # Input validation helper
    function Test-IPAddress {
        param($ip)
        return $ip -match '^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    }
    
    # Get source IP with validation
    do {
        Write-Host "Enter source IP address:" -ForegroundColor Yellow
        $sourceIP = Read-Host
        
        if ([string]::IsNullOrWhiteSpace($sourceIP)) {
            Write-Host "✗ Source IP cannot be empty" -ForegroundColor Red
            continue
        }
        
        if (-not (Test-IPAddress -ip $sourceIP)) {
            Write-Host "✗ Invalid IP address format" -ForegroundColor Red
            Write-Host "  Example: 192.168.1.1" -ForegroundColor Gray
            continue
        }
        
        break
    } while ($true)
    
    # Get destination IP with validation
    do {
        Write-Host "Enter destination IP address:" -ForegroundColor Yellow
        $destIP = Read-Host
        
        if ([string]::IsNullOrWhiteSpace($destIP)) {
            Write-Host "✗ Destination IP cannot be empty" -ForegroundColor Red
            continue
        }
        
        if (-not (Test-IPAddress -ip $destIP)) {
            Write-Host "✗ Invalid IP address format" -ForegroundColor Red
            Write-Host "  Example: 192.168.2.1" -ForegroundColor Gray
            continue
        }
        
        break
    } while ($true)
    
    Write-Host ""
    Write-Host "Optional parameters (press Enter to skip):" -ForegroundColor Cyan
    Write-Host ""
    
    # Get protocol with validation
    do {
        Write-Host "Protocol (TCP/UDP/ICMP) [default: ICMP]:" -ForegroundColor Yellow
        $protocol = Read-Host
        
        if ([string]::IsNullOrWhiteSpace($protocol)) {
            $protocol = "ICMP"
            break
        }
        
        if ($protocol -notin @("TCP", "UDP", "ICMP")) {
            Write-Host "✗ Invalid protocol. Must be TCP, UDP, or ICMP" -ForegroundColor Red
            continue
        }
        
        $protocol = $protocol.ToUpper()
        break
    } while ($true)
    
    # Get ports for TCP/UDP
    $sourcePort = $null
    $destPort = $null
    
    if ($protocol -ne "ICMP") {
        # Source port
        do {
            Write-Host "Source Port [optional, 1-65535]:" -ForegroundColor Yellow
            $sourcePortInput = Read-Host
            
            if ([string]::IsNullOrWhiteSpace($sourcePortInput)) {
                break
            }
            
            if ($sourcePortInput -notmatch '^\d+$' -or [int]$sourcePortInput -lt 1 -or [int]$sourcePortInput -gt 65535) {
                Write-Host "✗ Invalid port number. Must be between 1 and 65535" -ForegroundColor Red
                continue
            }
            
            $sourcePort = [int]$sourcePortInput
            break
        } while ($true)
        
        # Destination port
        do {
            Write-Host "Destination Port [optional, 1-65535]:" -ForegroundColor Yellow
            $destPortInput = Read-Host
            
            if ([string]::IsNullOrWhiteSpace($destPortInput)) {
                break
            }
            
            if ($destPortInput -notmatch '^\d+$' -or [int]$destPortInput -lt 1 -or [int]$destPortInput -gt 65535) {
                Write-Host "✗ Invalid port number. Must be between 1 and 65535" -ForegroundColor Red
                continue
            }
            
            $destPort = [int]$destPortInput
            break
        } while ($true)
    }
    
    # Additional options
    Write-Host ""
    Write-Host "Additional options:" -ForegroundColor Cyan
    Write-Host "Include detailed interface information? (yes/no) [default: yes]:" -ForegroundColor Yellow
    $detailedInfo = Read-Host
    if ([string]::IsNullOrWhiteSpace($detailedInfo)) { $detailedInfo = "yes" }
    
    Write-Host "Save results in JSON format as well? (yes/no) [default: yes]:" -ForegroundColor Yellow
    $saveJson = Read-Host
    if ([string]::IsNullOrWhiteSpace($saveJson)) { $saveJson = "yes" }
    
    Write-Host ""
    Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
    Write-Host "Path Trace Configuration:" -ForegroundColor Cyan
    Write-Host "  Source IP: $sourceIP" -ForegroundColor White
    Write-Host "  Destination IP: $destIP" -ForegroundColor White
    Write-Host "  Protocol: $protocol" -ForegroundColor White
    if ($sourcePort) { Write-Host "  Source Port: $sourcePort" -ForegroundColor White }
    if ($destPort) { Write-Host "  Destination Port: $destPort" -ForegroundColor White }
    Write-Host "  Detailed Info: $detailedInfo" -ForegroundColor White
    Write-Host "  Save JSON: $saveJson" -ForegroundColor White
    Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
    Write-Host ""
    
    $confirm = Read-Host "Start path trace? (yes/no)"
    if ($confirm -ne "yes") {
        Write-Host "✗ Operation cancelled" -ForegroundColor Yellow
        Read-Host "`nPress Enter to continue"
        return
    }
    
    Write-Host "`nInitiating path trace..." -ForegroundColor Yellow
    
    # Build request body
    $requestBody = @{
        "sourceIP" = $sourceIP
        "destIP" = $destIP
        "protocol" = $protocol
    }
    
    if ($sourcePort) { $requestBody["sourcePort"] = $sourcePort }
    if ($destPort) { $requestBody["destPort"] = $destPort }
    
    $requestJson = $requestBody | ConvertTo-Json -Depth 10
    
    try {
        # Initiate flow analysis
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/flow-analysis" `
            -Method Post `
            -Headers $headers `
            -Body $requestJson `
            -ContentType "application/json"
        
        if ($response -and $response.response -and $response.response.flowAnalysisId) {
            $flowAnalysisId = $response.response.flowAnalysisId
            Write-Host "✓ Flow analysis initiated (ID: $flowAnalysisId)" -ForegroundColor Green
            
            Write-Host "`nWaiting for path trace to complete..." -ForegroundColor Yellow
            
            $completed = $false
            $attempts = 0
            $maxAttempts = 30
            $startTime = Get-Date
            
            while (-not $completed -and $attempts -lt $maxAttempts) {
                Start-Sleep -Seconds 2
                $attempts++
                $elapsed = ((Get-Date) - $startTime).TotalSeconds
                
                # Check flow analysis status
                $statusResponse = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/flow-analysis/$flowAnalysisId" `
                    -Method Get `
                    -Headers $headers
                
                if ($statusResponse -and $statusResponse.response) {
                    $status = $statusResponse.response.request.status
                    
                    # Show progress with time
                    Write-Host "`r  Status: $status (attempt $attempts/$maxAttempts, elapsed: $([math]::Round($elapsed))s)" -NoNewline -ForegroundColor Cyan
                    
                    if ($status -eq "COMPLETED") {
                        $completed = $true
                        Write-Host "`n✓ Path trace completed!" -ForegroundColor Green
                        
                        # Parse and display results
                        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                        $csvPath = "$outputDir\PathTrace_${sourceIP}_to_${destIP}_$timestamp.csv"
                        
                        $pathList = @()
                        $hopNumber = 1
                        $totalLatency = 0
                        
                        # Prepare JSON structure
                        $jsonData = @{
                            PathTrace = @{
                                SourceIP = $sourceIP
                                DestinationIP = $destIP
                                Protocol = $protocol
                                SourcePort = $sourcePort
                                DestinationPort = $destPort
                                FlowAnalysisId = $flowAnalysisId
                                StartTime = $startTime.ToString("yyyy-MM-dd HH:mm:ss")
                                CompletionTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                                Status = $status
                                TotalHops = 0
                                PathHealthy = $statusResponse.response.request.periodicRefresh -eq $false
                                Hops = @()
                            }
                        }
                        
                        Write-Host ""
                        Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
                        Write-Host "Path Trace Results:" -ForegroundColor Cyan
                        Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
                        
                        if ($statusResponse.response.networkElementsInfo) {
                            foreach ($element in $statusResponse.response.networkElementsInfo) {
                                $deviceName = if ($element.name) { $element.name } else { "Unknown" }
                                $deviceIP = if ($element.ip) { $element.ip } else { "N/A" }
                                $deviceType = if ($element.type) { $element.type } else { "N/A" }
                                
                                # Enhanced interface extraction with better error handling
                                $ingressInterface = "N/A"
                                if ($element.ingressInterface) {
                                    if ($element.ingressInterface.physicalInterface -and $element.ingressInterface.physicalInterface.name) {
                                        $ingressInterface = $element.ingressInterface.physicalInterface.name
                                    } elseif ($element.ingressInterface.name) {
                                        $ingressInterface = $element.ingressInterface.name
                                    }
                                }
                                
                                $egressInterface = "N/A"
                                if ($element.egressInterface) {
                                    if ($element.egressInterface.physicalInterface -and $element.egressInterface.physicalInterface.name) {
                                        $egressInterface = $element.egressInterface.physicalInterface.name
                                    } elseif ($element.egressInterface.name) {
                                        $egressInterface = $element.egressInterface.name
                                    }
                                }
                                
                                # Extract additional information if available
                                $latency = if ($element.latency) { $element.latency } else { "N/A" }
                                if ($latency -ne "N/A" -and $latency -match '^\d+$') {
                                    $totalLatency += [int]$latency
                                }
                                
                                $interfaceType = "N/A"
                                if ($element.ingressInterface -and $element.ingressInterface.interfaceType) {
                                    $interfaceType = $element.ingressInterface.interfaceType
                                }
                                
                                # Display hop information
                                Write-Host "Hop $hopNumber`: $deviceName ($deviceIP)" -ForegroundColor White
                                Write-Host "  Type: $deviceType" -ForegroundColor Gray
                                Write-Host "  Path: $ingressInterface → $egressInterface" -ForegroundColor Gray
                                if ($latency -ne "N/A") { Write-Host "  Latency: $latency ms" -ForegroundColor Gray }
                                if ($detailedInfo -eq "yes" -and $interfaceType -ne "N/A") { 
                                    Write-Host "  Interface Type: $interfaceType" -ForegroundColor Gray 
                                }
                                Write-Host ""
                                
                                # Create hop object for CSV
                                $csvHop = [PSCustomObject]@{
                                    HopNumber = $hopNumber
                                    DeviceName = $deviceName
                                    DeviceIP = $deviceIP
                                    DeviceType = $deviceType
                                    IngressInterface = $ingressInterface
                                    EgressInterface = $egressInterface
                                    Latency = $latency
                                    InterfaceType = $interfaceType
                                    SourceIP = $sourceIP
                                    DestinationIP = $destIP
                                    Protocol = $protocol
                                    SourcePort = if ($sourcePort) { $sourcePort } else { "N/A" }
                                    DestinationPort = if ($destPort) { $destPort } else { "N/A" }
                                    TraceTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                                }
                                
                                $pathList += $csvHop
                                
                                # Create hop object for JSON
                                $jsonHop = [PSCustomObject]@{
                                    HopNumber = $hopNumber
                                    Device = @{
                                        Name = $deviceName
                                        IP = $deviceIP
                                        Type = $deviceType
                                    }
                                    Interfaces = @{
                                        Ingress = $ingressInterface
                                        Egress = $egressInterface
                                        Type = $interfaceType
                                    }
                                    Latency = $latency
                                }
                                
                                $jsonData.PathTrace.Hops += $jsonHop
                                $hopNumber++
                            }
                            
                            $jsonData.PathTrace.TotalHops = $pathList.Count
                            $jsonData.PathTrace.TotalLatency = $totalLatency
                        }
                        
                        Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
                        
                        # Export to CSV
                        $pathList | Export-Csv -Path $csvPath -NoTypeInformation
                        
                        Write-Host ""
                        Write-Host "✓ Path trace exported to: $csvPath" -ForegroundColor Green
                        Write-Host "✓ Total hops: $($pathList.Count)" -ForegroundColor Green
                        if ($totalLatency -gt 0) {
                            Write-Host "✓ Total estimated latency: $totalLatency ms" -ForegroundColor Green
                        }
                        
                        # Export to JSON if requested
                        if ($saveJson -eq "yes") {
                            $jsonPath = "$outputDir\PathTrace_${sourceIP}_to_${destIP}_$timestamp.json"
                            $jsonData | ConvertTo-Json -Depth 10 | Out-File -FilePath $jsonPath -Encoding UTF8
                            Write-Host "✓ JSON data exported to: $jsonPath" -ForegroundColor Green
                        }
                        
                        # Show path health and any issues
                        if ($statusResponse.response.request.periodicRefresh -eq $false) {
                            Write-Host "✓ Path is healthy" -ForegroundColor Green
                        } else {
                            Write-Host "⚠ Path may have issues (periodic refresh enabled)" -ForegroundColor Yellow
                        }
                        
                        # Check for additional warnings or errors
                        if ($statusResponse.response.request.failureReason) {
                            Write-Host "⚠ Warning: $($statusResponse.response.request.failureReason)" -ForegroundColor Yellow
                        }
                        
                    } elseif ($status -eq "FAILED") {
                        Write-Host "`n✗ Path trace failed" -ForegroundColor Red
                        if ($statusResponse.response.request.failureReason) {
                            Write-Host "  Reason: $($statusResponse.response.request.failureReason)" -ForegroundColor Red
                        }
                        break
                    } elseif ($status -eq "IN_PROGRESS") {
                        # Continue polling
                    } else {
                        Write-Host "`n⚠ Unknown status: $status" -ForegroundColor Yellow
                    }
                } else {
                    Write-Host "`n⚠ No response received from DNA Center" -ForegroundColor Yellow
                }
            }
            
            if (-not $completed -and $attempts -ge $maxAttempts) {
                Write-Host "`n✗ Path trace timed out after $([math]::Round(((Get-Date) - $startTime).TotalSeconds)) seconds" -ForegroundColor Red
            }
            
        } else {
            Write-Host "✗ Failed to initiate path trace" -ForegroundColor Red
            if ($response.response) {
                Write-Host "  Response: $($response.response | ConvertTo-Json -Depth 5)" -ForegroundColor Gray
            }
        }
        
    } catch {
        Write-Host "`n✗ Error during path trace: $($_.Exception.Message)" -ForegroundColor Red
        if ($_.ErrorDetails.Message) {
            try {
                $errorObj = $_.ErrorDetails.Message | ConvertFrom-Json
                if ($errorObj.response -and $errorObj.response.message) {
                    Write-Host "  Details: $($errorObj.response.message)" -ForegroundColor Red
                }
            } catch {
                Write-Host "  Details: $($_.ErrorDetails.Message)" -ForegroundColor Red
            }
        }
    }
    
    Write-Host ""
    Read-Host "Press Enter to continue"
}

# Include all your existing report functions here (1-20)
# I'll include just a few as examples - you already have these from before

function Get-NetworkDevicesBasic {
    param($headers, $dnaCenter)

    Write-Host "`nFetching network devices (basic info)..." -ForegroundColor Yellow

    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $deviceList = foreach ($device in $devices) {
        # Get the last known reachable time (column K)
        $lastPingReachableTime = Get-LastPingReachableTime -Headers $headers -DnaCenter $dnaCenter -Device $device
        
        # If no ping_reachable event, try to get from device properties
        if ($lastPingReachableTime -eq "N/A") {
            $lastReachableValue = Get-FirstPropertyValue -Object $device -PropertyNames @(
                'lastUpdated',
                'lastSeenTime',
                'lastSeen',
                'lastUpTime',
                'lastConnectedTime',
                'lastSuccessfulConnectionTime',
                'lastSyncTime'
            )

            if ($lastReachableValue) {
                $convertedReachable = ConvertTo-ReadableTimestamp $lastReachableValue
                if ($convertedReachable) {
                    $lastPingReachableTime = $convertedReachable
                }
            }
        }

        # Get the last time the device was unreachable (for reference)
        $lastUnreachableTime = Get-LastDeviceAvailabilityEventTime -Headers $headers -DnaCenter $dnaCenter -DeviceId $device.id -EventName "device_availability_unreachable"

        if (-not $lastUnreachableTime) {
            $lastUnreachableTime = Get-LastDisconnectTime -Headers $headers -DnaCenter $dnaCenter -DeviceId $device.id
        }

        if (-not $lastUnreachableTime) {
            $lastOfflineValue = Get-FirstPropertyValue -Object $device -PropertyNames @(
                'lastDownTime',
                'lastDisconnectedTime',
                'lastConnectionTime',
                'lastDisconnectionTime',
                'lastBootTime'
            )

            if ($lastOfflineValue) {
                $convertedOfflineValue = ConvertTo-ReadableTimestamp $lastOfflineValue
                if ($convertedOfflineValue) {
                    $lastUnreachableTime = $convertedOfflineValue
                }
            }
        }

        if (-not $lastUnreachableTime) {
            $lastOfflineFallback = Get-FirstPropertyValue -Object $device -PropertyNames @(
                'lastUpdated',
                'lastSeenTime',
                'lastSeen',
                'lastUpTime',
                'lastConnectedTime',
                'lastSuccessfulConnectionTime',
                'lastSyncTime'
            )

            if ($lastOfflineFallback) {
                $convertedFallback = ConvertTo-ReadableTimestamp $lastOfflineFallback
                if ($convertedFallback) {
                    $lastUnreachableTime = $convertedFallback
                }
            }
        }

        if (-not $lastUnreachableTime) {
            $lastUnreachableTime = "N/A"
        }

        [PSCustomObject]@{
            Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
            IPAddress = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
            SerialNumber = if ($device.serialNumber) { $device.serialNumber } else { "N/A" }
            Platform = if ($device.platformId) { $device.platformId } else { "N/A" }
            SoftwareVersion = if ($device.softwareVersion) { $device.softwareVersion } else { "N/A" }
            Role = if ($device.role) { $device.role } else { "N/A" }
            ReachabilityStatus = if ($device.reachabilityStatus) { $device.reachabilityStatus } else { "N/A" }
            Family = if ($device.family) { $device.family } else { "N/A" }
            Type = if ($device.type) { $device.type } else { "N/A" }
            UpTime = if ($device.upTime) { $device.upTime } else { "N/A" }
            LastPingReachableTime = $lastPingReachableTime  # Column K - device_availability:ping_reachable
            LastUnreachableEventTime = $lastUnreachableTime  # Column L - for reference
        }
    }

    Export-Report -Rows $deviceList -BaseName "NetworkDevices_Basic" -RecordLabel "devices" | Out-Null
}

# =====================================================
# FUNCTION 2: Network Devices (Detailed)
# =====================================================
function Get-NetworkDevicesDetailed {
    param($headers, $dnaCenter)

    Write-Host "`nFetching network devices (detailed info)..." -ForegroundColor Yellow

    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $deviceList = foreach ($device in $devices) {
        [PSCustomObject]@{
            Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
            IPAddress = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
            MacAddress = if ($device.macAddress) { $device.macAddress } else { "N/A" }
            SerialNumber = if ($device.serialNumber) { $device.serialNumber } else { "N/A" }
            Platform = if ($device.platformId) { $device.platformId } else { "N/A" }
            SoftwareVersion = if ($device.softwareVersion) { $device.softwareVersion } else { "N/A" }
            SoftwareType = if ($device.softwareType) { $device.softwareType } else { "N/A" }
            Role = if ($device.role) { $device.role } else { "N/A" }
            ReachabilityStatus = if ($device.reachabilityStatus) { $device.reachabilityStatus } else { "N/A" }
            Family = if ($device.family) { $device.family } else { "N/A" }
            Type = if ($device.type) { $device.type } else { "N/A" }
            Series = if ($device.series) { $device.series } else { "N/A" }
            Location = if ($device.location) { $device.location } else { "N/A" }
            LocationName = if ($device.locationName) { $device.locationName } else { "N/A" }
            MemorySize = if ($device.memorySize) { $device.memorySize } else { "N/A" }
            LastUpdated = if ($device.lastUpdated) { $device.lastUpdated } else { "N/A" }
            CollectionStatus = if ($device.collectionStatus) { $device.collectionStatus } else { "N/A" }
            ErrorCode = if ($device.errorCode) { $device.errorCode } else { "N/A" }
            ErrorDescription = if ($device.errorDescription) { $device.errorDescription } else { "N/A" }
            UpTime = if ($device.upTime) { $device.upTime } else { "N/A" }
            BootDateTime = if ($device.bootDateTime) { $device.bootDateTime } else { "N/A" }
            ApManagerInterfaceIp = if ($device.apManagerInterfaceIp) { $device.apManagerInterfaceIp } else { "N/A" }
            AssociatedWlcIp = if ($device.associatedWlcIp) { $device.associatedWlcIp } else { "N/A" }
            InstanceUuid = if ($device.instanceUuid) { $device.instanceUuid } else { "N/A" }
            Id = if ($device.id) { $device.id } else { "N/A" }
        }
    }

    Export-Report -Rows $deviceList -BaseName "NetworkDevices_Detailed" -RecordLabel "devices" | Out-Null
}

# =====================================================
# FUNCTION 3: Device Configurations
# =====================================================
function Get-DeviceConfigurations {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching device configurations..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $configList = @()
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $configFolder = $null
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        $configContent = $null
        $status = "Failed"
        $configPath = $null
        $preview = "N/A"
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/network-device/$($device.id)/config" -Method Get -Headers $headers
            $configContent = Get-ConfigText -Response $response

            if ($configContent) {
                $status = "Retrieved"
                $preview = if ($configContent.Length -gt 160) { $configContent.Substring(0, 160) + "..." } else { $configContent }

                if (-not $configFolder) {
                    $configFolder = Join-Path -Path $outputDir -ChildPath ("DeviceConfigurations_{0}" -f $timestamp)
                    New-Item -ItemType Directory -Path $configFolder -Force | Out-Null
                }

                $identifierParts = @()
                if ($device.hostname) { $identifierParts += $device.hostname }
                if ($device.managementIpAddress) { $identifierParts += $device.managementIpAddress }
                if ($device.id) { $identifierParts += $device.id }
                if ($identifierParts.Count -eq 0) { $identifierParts = @("device", [guid]::NewGuid().ToString()) }

                $fileBase = Get-SafeFileName -InputName ($identifierParts -join "_")
                $configPath = Join-Path -Path $configFolder -ChildPath ("{0}.txt" -f $fileBase)
                Set-Content -Path $configPath -Value $configContent -Encoding UTF8 -Force
            }
            else {
                $status = "Empty"
            }
        }
        catch {
            Write-Host "    ✗ Failed to retrieve configuration for $($device.hostname): $($_.Exception.Message)" -ForegroundColor Red
        }

        $configList += [PSCustomObject]@{
            Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
            IPAddress = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
            ConfigStatus = $status
            ConfigSize = if ($configContent) { $configContent.Length } else { 0 }
            ConfigPreview = $preview
            ConfigFile = if ($configPath) { $configPath } else { "N/A" }
            LastBackup = if ($device.lastUpdated) { $device.lastUpdated } else { "N/A" }
            DeviceId = $device.id
        }
    }
    
    $exportPath = Export-Report -Rows $configList -BaseName "DeviceConfigurations" -RecordLabel "configuration records" -Timestamp $timestamp

    if ($configFolder -and (Test-Path $configFolder)) {
        Write-Host "✓ Saved raw configuration files to: $configFolder" -ForegroundColor Green
    }

    if (-not $exportPath) {
        Write-Host "! No configuration metadata exported." -ForegroundColor Yellow
    }
}

# =====================================================
# FUNCTION 4: Device Interfaces
# =====================================================
function Get-DeviceInterfaces {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching device interfaces..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $interfaceList = @()
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/interface/network-device/$($device.id)" -Method Get -Headers $headers
            
            if ($response -and $response.response) {
                foreach ($interface in $response.response) {
                    $interfaceList += [PSCustomObject]@{
                        Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                        InterfaceName = if ($interface.portName) { $interface.portName } else { "N/A" }
                        Status = if ($interface.status) { $interface.status } else { "N/A" }
                        AdminStatus = if ($interface.adminStatus) { $interface.adminStatus } else { "N/A" }
                        Speed = if ($interface.speed) { $interface.speed } else { "N/A" }
                        Duplex = if ($interface.duplex) { $interface.duplex } else { "N/A" }
                        PortMode = if ($interface.portMode) { $interface.portMode } else { "N/A" }
                        PortType = if ($interface.portType) { $interface.portType } else { "N/A" }
                        VlanId = if ($interface.vlanId) { $interface.vlanId } else { "N/A" }
                        VoiceVlan = if ($interface.voiceVlan) { $interface.voiceVlan } else { "N/A" }
                        IPAddress = if ($interface.ipv4Address) { $interface.ipv4Address } else { "N/A" }
                        SubnetMask = if ($interface.ipv4Mask) { $interface.ipv4Mask } else { "N/A" }
                        MacAddress = if ($interface.macAddress) { $interface.macAddress } else { "N/A" }
                        Description = if ($interface.description) { $interface.description } else { "N/A" }
                    }
                }
            }
        }
        catch {
            Write-Host "    ✗ Failed to get interfaces for $($device.hostname)" -ForegroundColor Red
        }
    }
    
    Export-Report -Rows $interfaceList -BaseName "DeviceInterfaces" -RecordLabel "interfaces" | Out-Null
}

# =====================================================
# FUNCTION 5: Device Inventory Count
# =====================================================
function Get-DeviceInventoryCount {
    param($headers, $dnaCenter)
    
    Write-Host "`nCalculating device inventory counts..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    # Group by various attributes
    $byFamily = Convert-GroupToRows -Groups ($devices | Group-Object -Property family) -PropertyName "Family" -SortDescending
    $byRole = Convert-GroupToRows -Groups ($devices | Group-Object -Property role) -PropertyName "Role" -SortDescending
    $byType = Convert-GroupToRows -Groups ($devices | Group-Object -Property type) -PropertyName "Type" -SortDescending
    $byPlatform = Convert-GroupToRows -Groups ($devices | Group-Object -Property platformId) -PropertyName "Platform" -SortDescending
    $bySoftware = Convert-GroupToRows -Groups ($devices | Group-Object -Property softwareVersion) -PropertyName "SoftwareVersion" -SortDescending
    $byReachability = Convert-GroupToRows -Groups ($devices | Group-Object -Property reachabilityStatus) -PropertyName "ReachabilityStatus" -SortDescending

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"

    Export-Report -Rows $byFamily -BaseName "DeviceInventory_ByFamily" -RecordLabel "family counts" -Timestamp $timestamp | Out-Null
    Export-Report -Rows $byRole -BaseName "DeviceInventory_ByRole" -RecordLabel "role counts" -Timestamp $timestamp | Out-Null
    Export-Report -Rows $byType -BaseName "DeviceInventory_ByType" -RecordLabel "type counts" -Timestamp $timestamp | Out-Null
    Export-Report -Rows $byPlatform -BaseName "DeviceInventory_ByPlatform" -RecordLabel "platform counts" -Timestamp $timestamp | Out-Null
    Export-Report -Rows $bySoftware -BaseName "DeviceInventory_BySoftware" -RecordLabel "software counts" -Timestamp $timestamp | Out-Null
    Export-Report -Rows $byReachability -BaseName "DeviceInventory_ByReachability" -RecordLabel "reachability counts" -Timestamp $timestamp | Out-Null

    Write-Host "✓ Total devices: $($devices.Count)" -ForegroundColor Green
}

# =====================================================
# FUNCTION 6: Sites/Locations
# =====================================================
function Get-SitesLocations {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching sites and locations..." -ForegroundColor Yellow
    
    try {
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/site" -Method Get -Headers $headers
        
        $siteList = @()
        if ($response -and $response.response) {
            foreach ($site in $response.response) {
                $siteList += [PSCustomObject]@{
                    SiteName = if ($site.name) { $site.name } else { "N/A" }
                    SiteId = if ($site.id) { $site.id } else { "N/A" }
                    ParentId = if ($site.parentId) { $site.parentId } else { "N/A" }
                    SiteType = if ($site.additionalInfo) { 
                        ($site.additionalInfo | ForEach-Object { if ($_.nameSpace -eq "Location") { $_.attributes.type } }) -join ", "
                    } else { "N/A" }
                    Latitude = if ($site.latitude) { $site.latitude } else { "N/A" }
                    Longitude = if ($site.longitude) { $site.longitude } else { "N/A" }
                }
            }
        }
        
        Export-Report -Rows $siteList -BaseName "Sites" -RecordLabel "sites" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve sites: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# FUNCTION 7: Network Health
# =====================================================
function Get-NetworkHealth {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching network health..." -ForegroundColor Yellow
    
    try {
        $timestamp_ms = [DateTimeOffset]::UtcNow.ToUnixTimeMilliseconds()
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/network-health?timestamp=$timestamp_ms" -Method Get -Headers $headers
        
        $healthList = @()
        if ($response -and $response.response) {
            foreach ($item in $response.response) {
                $healthList += [PSCustomObject]@{
                    HealthCategory = if ($item.healthCategory) { $item.healthCategory } else { "N/A" }
                    TotalCount = if ($item.totalCount) { $item.totalCount } else { 0 }
                    GoodCount = if ($item.goodCount) { $item.goodCount } else { 0 }
                    FairCount = if ($item.fairCount) { $item.fairCount } else { 0 }
                    BadCount = if ($item.badCount) { $item.badCount } else { 0 }
                    UnmonitoredCount = if ($item.unmonCount) { $item.unmonCount } else { 0 }
                    HealthScore = if ($item.healthScore) { $item.healthScore } else { 0 }
                }
            }
        }
        
        Export-Report -Rows $healthList -BaseName "NetworkHealth" -RecordLabel "health categories" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve network health: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# FUNCTION 8: Client Health
# =====================================================
function Get-ClientHealth {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching client health..." -ForegroundColor Yellow
    
    try {
        $timestamp_ms = [DateTimeOffset]::UtcNow.ToUnixTimeMilliseconds()
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/client-health?timestamp=$timestamp_ms" -Method Get -Headers $headers
        
        $clientList = @()
        if ($response -and $response.response) {
            foreach ($client in $response.response) {
                $clientList += [PSCustomObject]@{
                    SiteId = if ($client.siteId) { $client.siteId } else { "N/A" }
                    TotalCount = if ($client.scoreDetail) { $client.scoreDetail.totalCount } else { 0 }
                    ConnectedCount = if ($client.scoreDetail) { $client.scoreDetail.connectedCount } else { 0 }
                    GoodCount = if ($client.scoreDetail) { $client.scoreDetail.clientCount.good } else { 0 }
                    FairCount = if ($client.scoreDetail) { $client.scoreDetail.clientCount.fair } else { 0 }
                    PoorCount = if ($client.scoreDetail) { $client.scoreDetail.clientCount.poor } else { 0 }
                    HealthScore = if ($client.scoreDetail) { $client.scoreDetail.healthScore } else { 0 }
                }
            }
        }
        
        Export-Report -Rows $clientList -BaseName "ClientHealth" -RecordLabel "client health records" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve client health: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# FUNCTION 9: Compliance Status
# =====================================================
function Get-ComplianceStatus {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching compliance status..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $complianceList = @()
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/compliance/$($device.id)" -Method Get -Headers $headers
            
            if ($response -and $response.response) {
                $complianceList += [PSCustomObject]@{
                    Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                    IPAddress = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                    ComplianceStatus = if ($response.response.status) { $response.response.status } else { "N/A" }
                    LastSyncTime = if ($response.response.lastSyncTime) { $response.response.lastSyncTime } else { "N/A" }
                    DeviceId = $device.id
                }
            }
        }
        catch {
            $complianceList += [PSCustomObject]@{
                Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                IPAddress = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                ComplianceStatus = "Unknown"
                LastSyncTime = "N/A"
                DeviceId = $device.id
            }
        }
    }
    
    Export-Report -Rows $complianceList -BaseName "ComplianceStatus" -RecordLabel "compliance records" | Out-Null
}

# =====================================================
# FUNCTION 10: Device Reachability Status
# =====================================================
function Get-DeviceReachability {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching device reachability status..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $reachabilityList = @()
    foreach ($device in $devices) {
        $reachabilityList += [PSCustomObject]@{
            Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
            IPAddress = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
            ReachabilityStatus = if ($device.reachabilityStatus) { $device.reachabilityStatus } else { "N/A" }
            LastUpdated = if ($device.lastUpdated) { $device.lastUpdated } else { "N/A" }
            CollectionStatus = if ($device.collectionStatus) { $device.collectionStatus } else { "N/A" }
            ErrorCode = if ($device.errorCode) { $device.errorCode } else { "None" }
            ErrorDescription = if ($device.errorDescription) { $device.errorDescription } else { "None" }
            Family = if ($device.family) { $device.family } else { "N/A" }
            Role = if ($device.role) { $device.role } else { "N/A" }
        }
    }
    
    Export-Report -Rows $reachabilityList -BaseName "DeviceReachability" -RecordLabel "device reachability entries" | Out-Null
}

# =====================================================
# FUNCTION 11: VLANs
# =====================================================
function Get-VLANs {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching VLANs..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $vlanList = @()
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/interface/network-device/$($device.id)" -Method Get -Headers $headers
            
            if ($response -and $response.response) {
                $vlans = $response.response | Where-Object { $_.vlanId -and $_.vlanId -ne "N/A" } | Select-Object -Property vlanId -Unique
                
                foreach ($vlan in $vlans) {
                    $vlanList += [PSCustomObject]@{
                        Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                        IPAddress = if ($device.managementIpAddress) { $device.managementIpAddress } else { "N/A" }
                        VlanId = $vlan.vlanId
                        DeviceId = $device.id
                    }
                }
            }
        }
        catch {
            Write-Host "    ✗ Failed to get VLANs for $($device.hostname)" -ForegroundColor Red
        }
    }
    
    Export-Report -Rows $vlanList -BaseName "VLANs" -RecordLabel "VLAN entries" | Out-Null
}

# =====================================================
# FUNCTION 12: Software/Image Information
# =====================================================
function Get-SoftwareImageInfo {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching software/image information..." -ForegroundColor Yellow
    
    try {
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/image/importation" -Method Get -Headers $headers
        
        $imageList = @()
        if ($response -and $response.response) {
            foreach ($image in $response.response) {
                $imageList += [PSCustomObject]@{
                    ImageName = if ($image.name) { $image.name } else { "N/A" }
                    ImageFamily = if ($image.family) { $image.family } else { "N/A" }
                    Version = if ($image.version) { $image.version } else { "N/A" }
                    Vendor = if ($image.vendor) { $image.vendor } else { "N/A" }
                    FileSize = if ($image.fileSize) { $image.fileSize } else { "N/A" }
                    IsTaggedGolden = if ($image.isTaggedGolden) { $image.isTaggedGolden } else { $false }
                    ImageType = if ($image.imageType) { $image.imageType } else { "N/A" }
                    CreatedTime = if ($image.createdTime) { $image.createdTime } else { "N/A" }
                    ImageUuid = if ($image.imageUuid) { $image.imageUuid } else { "N/A" }
                }
            }
        }
        
        Export-Report -Rows $imageList -BaseName "SoftwareImages" -RecordLabel "software images" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve software images: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# FUNCTION 13: Issues/Events
# =====================================================
function Get-IssuesEvents {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching issues and events..." -ForegroundColor Yellow
    
    try {
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/issues" -Method Get -Headers $headers
        
        $issueList = @()
        if ($response -and $response.response) {
            foreach ($issue in $response.response) {
                $issueList += [PSCustomObject]@{
                    IssueId = if ($issue.issueId) { $issue.issueId } else { "N/A" }
                    Name = if ($issue.name) { $issue.name } else { "N/A" }
                    DeviceId = if ($issue.deviceId) { $issue.deviceId } else { "N/A" }
                    Severity = if ($issue.severity) { $issue.severity } else { "N/A" }
                    Priority = if ($issue.priority) { $issue.priority } else { "N/A" }
                    Status = if ($issue.status) { $issue.status } else { "N/A" }
                    Category = if ($issue.category) { $issue.category } else { "N/A" }
                    LastOccurenceTime = if ($issue.lastOccurenceTime) { $issue.lastOccurenceTime } else { "N/A" }
                    Description = if ($issue.description) { $issue.description } else { "N/A" }
                }
            }
        }
        
        Export-Report -Rows $issueList -BaseName "Issues" -RecordLabel "issues" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve issues: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# FUNCTION 14: Templates
# =====================================================
function Get-Templates {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching configuration templates..." -ForegroundColor Yellow
    
    try {
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/template-programmer/template" -Method Get -Headers $headers

        $templateList = @()
        $templates = @()

        if ($response) {
            if ($response.response) {
                $templates = $response.response
            }
            elseif ($response -is [System.Collections.IEnumerable]) {
                $templates = $response
            }
            else {
                $templates = @($response)
            }
        }

        foreach ($template in $templates) {
            $templateList += [PSCustomObject]@{
                TemplateName = if ($template.name) { $template.name } else { "N/A" }
                ProjectName = if ($template.projectName) { $template.projectName } else { "N/A" }
                TemplateId = if ($template.templateId) { $template.templateId } else { "N/A" }
                SoftwareType = if ($template.softwareType) { $template.softwareType } else { "N/A" }
                SoftwareVersion = if ($template.softwareVersion) { $template.softwareVersion } else { "N/A" }
                DeviceTypes = if ($template.deviceTypes) { ($template.deviceTypes | ForEach-Object { $_.productFamily }) -join ", " } else { "N/A" }
                CreateTime = if ($template.createTime) { $template.createTime } else { "N/A" }
                LastUpdateTime = if ($template.lastUpdateTime) { $template.lastUpdateTime } else { "N/A" }
            }
        }

        Export-Report -Rows $templateList -BaseName "Templates" -RecordLabel "templates" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve templates: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# FUNCTION 15: Physical Topology
# =====================================================
function Get-PhysicalTopology {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching physical topology..." -ForegroundColor Yellow
    
    try {
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/topology/physical-topology" -Method Get -Headers $headers
        
        $linkList = @()
        if ($response -and $response.response -and $response.response.links) {
            foreach ($link in $response.response.links) {
                $linkList += [PSCustomObject]@{
                    SourceDevice = if ($link.source) { $link.source } else { "N/A" }
                    SourceInterface = if ($link.startPortName) { $link.startPortName } else { "N/A" }
                    TargetDevice = if ($link.target) { $link.target } else { "N/A" }
                    TargetInterface = if ($link.endPortName) { $link.endPortName } else { "N/A" }
                    LinkStatus = if ($link.linkStatus) { $link.linkStatus } else { "N/A" }
                }
            }
        }
        
        Export-Report -Rows $linkList -BaseName "PhysicalTopology" -RecordLabel "links" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve physical topology: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# =====================================================
# FUNCTION 16: Device Module Information
# =====================================================
function Get-DeviceModules {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching device module information..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $moduleList = @()
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/network-device/module?deviceId=$($device.id)" -Method Get -Headers $headers
            
            if ($response -and $response.response) {
                foreach ($module in $response.response) {
                    $moduleList += [PSCustomObject]@{
                        Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                        ModuleName = if ($module.name) { $module.name } else { "N/A" }
                        PartNumber = if ($module.partNumber) { $module.partNumber } else { "N/A" }
                        SerialNumber = if ($module.serialNumber) { $module.serialNumber } else { "N/A" }
                        Description = if ($module.description) { $module.description } else { "N/A" }
                        ModuleIndex = if ($module.moduleIndex) { $module.moduleIndex } else { "N/A" }
                        OperationalStateCode = if ($module.operationalStateCode) { $module.operationalStateCode } else { "N/A" }
                        VendorEquipmentType = if ($module.vendorEquipmentType) { $module.vendorEquipmentType } else { "N/A" }
                    }
                }
            }
        }
        catch {
            Write-Host "    ✗ Failed to get modules for $($device.hostname)" -ForegroundColor Red
        }
    }
    
    Export-Report -Rows $moduleList -BaseName "DeviceModules" -RecordLabel "module entries" | Out-Null
}

# =====================================================
# FUNCTION 17: OSPF Neighbors
# =====================================================
function Get-OSPFNeighbors {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching OSPF neighbors..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $ospfList = @()
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/network-device/$($device.id)/ospf-neighbor" -Method Get -Headers $headers
            
            if ($response -and $response.response) {
                foreach ($neighbor in $response.response) {
                    $ospfList += [PSCustomObject]@{
                        Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                        NeighborId = if ($neighbor.neighborId) { $neighbor.neighborId } else { "N/A" }
                        NeighborIp = if ($neighbor.neighborIp) { $neighbor.neighborIp } else { "N/A" }
                        State = if ($neighbor.state) { $neighbor.state } else { "N/A" }
                        Interface = if ($neighbor.interfaceName) { $neighbor.interfaceName } else { "N/A" }
                    }
                }
            }
        }
        catch {
            # OSPF may not be configured - silent skip
        }
    }
    
    Export-Report -Rows $ospfList -BaseName "OSPF_Neighbors" -RecordLabel "OSPF neighbors" | Out-Null
}

# =====================================================
# FUNCTION 18: CDP Neighbors
# =====================================================
function Get-CDPNeighbors {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching CDP neighbors..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $cdpList = @()
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/network-device/$($device.id)/neighbor" -Method Get -Headers $headers
            
            if ($response -and $response.response) {
                foreach ($neighbor in $response.response) {
                    if ($neighbor.neighborDevice -or $neighbor.neighborPort) {
                        $cdpList += [PSCustomObject]@{
                            Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                            LocalInterface = if ($neighbor.localInterfaceName) { $neighbor.localInterfaceName } else { "N/A" }
                            NeighborDevice = if ($neighbor.neighborDevice) { $neighbor.neighborDevice } else { "N/A" }
                            NeighborPort = if ($neighbor.neighborPort) { $neighbor.neighborPort } else { "N/A" }
                            Platform = if ($neighbor.platform) { $neighbor.platform } else { "N/A" }
                            Capabilities = if ($neighbor.capabilities) { $neighbor.capabilities } else { "N/A" }
                        }
                    }
                }
            }
        }
        catch {
            Write-Host "    ✗ Failed to get CDP neighbors for $($device.hostname)" -ForegroundColor Red
        }
    }
    
    Export-Report -Rows $cdpList -BaseName "CDP_Neighbors" -RecordLabel "CDP neighbors" | Out-Null
}

# =====================================================
# FUNCTION 19: LLDP Neighbors
# =====================================================
function Get-LLDPNeighbors {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching LLDP neighbors..." -ForegroundColor Yellow
    
    $devices = Get-ActiveDevices
    if (-not $devices) { return }

    $lldpList = @()
    
    foreach ($device in $devices) {
        Write-Host "  Processing: $($device.hostname)" -ForegroundColor Gray
        
        try {
            $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/network-device/$($device.id)/interface/lldp" -Method Get -Headers $headers
            
            if ($response -and $response.response) {
                foreach ($neighbor in $response.response) {
                    $lldpList += [PSCustomObject]@{
                        Hostname = if ($device.hostname) { $device.hostname } else { "Unknown" }
                        LocalInterface = if ($neighbor.localInterface) { $neighbor.localInterface } else { "N/A" }
                        NeighborDevice = if ($neighbor.systemName) { $neighbor.systemName } else { "N/A" }
                        NeighborPort = if ($neighbor.portId) { $neighbor.portId } else { "N/A" }
                        ManagementAddress = if ($neighbor.managementAddress) { $neighbor.managementAddress } else { "N/A" }
                        SystemDescription = if ($neighbor.systemDescription) { $neighbor.systemDescription } else { "N/A" }
                    }
                }
            }
        }
        catch {
            # LLDP may not be available - silent skip
        }
    }
    
    Export-Report -Rows $lldpList -BaseName "LLDP_Neighbors" -RecordLabel "LLDP neighbors" | Out-Null
}

# =====================================================
# FUNCTION 20: Access Points
# =====================================================
function Get-AccessPoints {
    param($headers, $dnaCenter)
    
    Write-Host "`nFetching access points..." -ForegroundColor Yellow
    
    try {
        $response = Invoke-RestMethod -Uri "$dnaCenter/dna/intent/api/v1/wireless/access-point" -Method Get -Headers $headers
        
        $apList = @()
        if ($response -and $response.response) {
            foreach ($ap in $response.response) {
                $apList += [PSCustomObject]@{
                    APName = if ($ap.name) { $ap.name } else { "N/A" }
                    MacAddress = if ($ap.macAddress) { $ap.macAddress } else { "N/A" }
                    IPAddress = if ($ap.ipAddress) { $ap.ipAddress } else { "N/A" }
                    Model = if ($ap.model) { $ap.model } else { "N/A" }
                    SerialNumber = if ($ap.serialNumber) { $ap.serialNumber } else { "N/A" }
                    Location = if ($ap.location) { $ap.location } else { "N/A" }
                    AdminStatus = if ($ap.adminStatus) { $ap.adminStatus } else { "N/A" }
                    OperationStatus = if ($ap.operationStatus) { $ap.operationStatus } else { "N/A" }
                    WLCName = if ($ap.controllerName) { $ap.controllerName } else { "N/A" }
                    ClientCount = if ($ap.clientCount) { $ap.clientCount } else { 0 }
                    SoftwareVersion = if ($ap.softwareVersion) { $ap.softwareVersion } else { "N/A" }
                }
            }
        }
        
        Export-Report -Rows $apList -BaseName "AccessPoints" -RecordLabel "access points" | Out-Null
    }
    catch {
        Write-Host "✗ Failed to retrieve access points: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Main script execution
Show-Banner

# Authenticate
$token = Get-DNACToken -dnaCenter $dnaCenter

if (-not $token) {
    Write-Host "`n✗ Authentication failed. Exiting...`n" -ForegroundColor Red
    Write-Host "Press Enter to exit..."
    Read-Host
    exit
}

# Create headers for API calls
$apiHeaders = @{
    "X-Auth-Token" = $token
    "Content-Type" = "application/json"
}

# Load all devices
$loadSuccess = Load-AllDevices -headers $apiHeaders -dnaCenter $dnaCenter

if (-not $loadSuccess) {
    Write-Host "✗ Failed to load devices. Exiting..." -ForegroundColor Red
    Write-Host "Press Enter to exit..."
    Read-Host
    exit
}

Write-Host "`nOutput directory: $outputDir" -ForegroundColor Cyan

# Main menu loop
$selectedOptions = @()

do {
    Show-Menu
    $selection = Read-Host "Select option"
    if ($null -ne $selection) {
        $selection = $selection.Trim()
    }

    if ($selection -eq "0") {
        break
    }
    elseif ($selection -eq "99") {
        Select-Devices -headers $apiHeaders -dnaCenter $dnaCenter
        continue
    }

    # Handle new advanced operations immediately (don't queue)
    elseif ($selection -eq "21") {
        Invoke-CommandRunner -headers $apiHeaders -dnaCenter $dnaCenter
        continue
    }
    elseif ($selection -eq "22") {
        Invoke-PathTrace -headers $apiHeaders -dnaCenter $dnaCenter
        continue
    }
    elseif ($selection -match '^\d+$') {
        $selNum = [int]$selection
        if ($selNum -ge 1 -and $selNum -le 20) {
            if ($selectedOptions -notcontains $selection) {
                $selectedOptions += $selection
                Write-Host "✓ Added option $selection to queue" -ForegroundColor Green
            } else {
                Write-Host "! Option $selection already in queue" -ForegroundColor Yellow
            }
        } else {
            Write-Host "✗ Invalid selection" -ForegroundColor Red
        }
    }
    else {
        Write-Host "✗ Invalid selection" -ForegroundColor Red
    }
    
    if ($selectedOptions.Count -gt 0) {
        Write-Host "`nCurrent queue: $($selectedOptions -join ', ')" -ForegroundColor Cyan
    }
    Write-Host ""
    Read-Host "Press Enter to continue"
    
} while ($true)

# Process all selected options
if ($selectedOptions.Count -gt 0) {
    Write-Host ""
    Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
    Write-Host "Processing $($selectedOptions.Count) report(s)..." -ForegroundColor Cyan
    
    if ($global:selectedDevices.Count -gt 0) {
        Write-Host "Device filter: $($global:selectedDevices.Count) device(s)" -ForegroundColor Yellow
    } else {
        Write-Host "Device filter: All devices" -ForegroundColor Green
    }
    Write-Host "═══════════════════════════════════════" -ForegroundColor Cyan
    
    foreach ($option in $selectedOptions) {
        $reportLabel = switch ($option) {
            default { "Report $option" }
        }

        Write-Host "`n--- $reportLabel ---" -ForegroundColor Cyan

        switch ($option) {
            "1"  { Get-NetworkDevicesBasic -headers $apiHeaders -dnaCenter $dnaCenter }
            "2"  { Get-NetworkDevicesDetailed -headers $apiHeaders -dnaCenter $dnaCenter }
            "3"  { Get-DeviceConfigurations -headers $apiHeaders -dnaCenter $dnaCenter }
            "4"  { Get-DeviceInterfaces -headers $apiHeaders -dnaCenter $dnaCenter }
            "5"  { Get-DeviceInventoryCount -headers $apiHeaders -dnaCenter $dnaCenter }
            "6"  { Get-SitesLocations -headers $apiHeaders -dnaCenter $dnaCenter }
            "7"  { Get-NetworkHealth -headers $apiHeaders -dnaCenter $dnaCenter }
            "8"  { Get-ClientHealth -headers $apiHeaders -dnaCenter $dnaCenter }
            "9"  { Get-ComplianceStatus -headers $apiHeaders -dnaCenter $dnaCenter }
            "10" { Get-DeviceReachability -headers $apiHeaders -dnaCenter $dnaCenter }
            "11" { Get-VLANs -headers $apiHeaders -dnaCenter $dnaCenter }
            "12" { Get-SoftwareImageInfo -headers $apiHeaders -dnaCenter $dnaCenter }
            "13" { Get-IssuesEvents -headers $apiHeaders -dnaCenter $dnaCenter }
            "14" { Get-Templates -headers $apiHeaders -dnaCenter $dnaCenter }
            "15" { Get-PhysicalTopology -headers $apiHeaders -dnaCenter $dnaCenter }
            "16" { Get-DeviceModules -headers $apiHeaders -dnaCenter $dnaCenter }
            "17" { Get-OSPFNeighbors -headers $apiHeaders -dnaCenter $dnaCenter }
            "18" { Get-CDPNeighbors -headers $apiHeaders -dnaCenter $dnaCenter }
            "19" { Get-LLDPNeighbors -headers $apiHeaders -dnaCenter $dnaCenter }
            "20" { Get-AccessPoints -headers $apiHeaders -dnaCenter $dnaCenter }
        }
    }
    
    Write-Host ""
    Write-Host "═══════════════════════════════════════" -ForegroundColor Green
    Write-Host "All reports completed!" -ForegroundColor Green
    Write-Host "Files saved to: $outputDir" -ForegroundColor Green
    Write-Host "═══════════════════════════════════════" -ForegroundColor Green
    Write-Host ""
} else {
    Write-Host "`nNo options selected. Exiting...`n" -ForegroundColor Yellow
}

Write-Host "Press Enter to exit..."
Read-Host
